---
title: Notes | Reverse | BOF
author: BatBato
date: 2022-12-07
categories: [Notes, Reverse, BOF]
tags: [Reverse, BOF]
permalink: /Notes/Reverse/BOF
---

# Buffer Overflow

From here I'm assuming that you already know a bit about ASM (```mov```, ```call```, ```lea```...). If you don't there is a good introduction in [here](https://cloud.isi.insa-cvl.fr/s/qWmEqLkSGXnkLZn).

So basicaly, the buffer overflow attack apear when you don't pay attention to the user input and that he gives you a greater input that what you expected. This surplus, will overwrite the memory.

We need to keep in mind the endianness of the program. If for example, we have a word ```\xAA\xBB\xCC\xDD``` at the address ```0xffff0000```, then depending on the endianness the word will be read differently :

| Memory Address | 	0xffff0000 | 	0xffff0001 | 	0xffff0002 | 	0xffff0003 |
|---|---|---|---|---|
| Big-Endian 	|AA | 	BB | 	CC | 	DD |
| Little-Endian | 	DD | 	CC | 	BB | 	AA |

What we would like to do is to give a greater input than the one expected so that we overwrite the return of the program. Thanks to that, we will be able to call another function or something else in the memory. Here is an image that shows basically what we want to do :

![image](https://user-images.githubusercontent.com/73934639/206201166-ef62b19e-10da-4ae2-a3b5-d7139375b54f.png){: width="300" height="100" }

At first, we will try to find the main function and its address. For that, we can use gdb or radar2. I will continue this explanation using gdb syntax but it is basically the same on r2. We will run the program until we get to the input part, when we get there we can input a large number of ```A``` and if we inputed enought A, we should get a :
```sh
Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
```
The ```41``` are the hexadecimal value of ```A```. Now that we know that we overwrote the return address we need to find how much ```A``` we need to input before getting a segmentation fault. We can use the ```pattern_offset``` tool of ```metasploit``` to generate a random string of certain length so we don't have a bunch of ```41``` in the memory. We can use it as follows:
```sh
pattern_create.rb -l 1200
```
> This program should be in the ```metasploit-framework``` folder. On my computer it is located at ```/usr/share/metasploit-framework/tools/exploit/pattern_create.rb``` {: .prompt-info }

We can use the gdb command to find the address of ```EIP``` (respectively ```RIP``` depending on the architecture) :
```sh
info registers eip
```
With this information you can use the metasploit ```pattern_offset.rb``` tool to find the exact offset. Or if you are good in ASM you can look what is the length of the word you give in input. You can use the tool as follows (where 0xaabbccdd is the address of eip you found earlier):
```pattern_offset.rb -q 0xaabbccdd```
