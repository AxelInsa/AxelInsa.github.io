<feed xmlns="http://www.w3.org/2005/Atom"> <id>axelinsa.github.io/</id><title>Stillwolfing's blog</title><subtitle>A blog to take notes of what I learn, Writ-Up and many more...</subtitle> <updated>2024-11-02T18:02:22+01:00</updated> <author> <name>AxelInsa</name> <uri>axelinsa.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="axelinsa.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="axelinsa.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2024 AxelInsa </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Notes | Server-Side Request Forgery (SSRF)</title><link href="axelinsa.github.io/Notes/Web/server-side_request_forgery_(ssrf)" rel="alternate" type="text/html" title="Notes | Server-Side Request Forgery (SSRF)" /><published>2024-11-02T00:00:00+01:00</published> <updated>2024-11-02T18:01:34+01:00</updated> <id>axelinsa.github.io/Notes/Web/server-side_request_forgery_(ssrf)</id> <content src="axelinsa.github.io/Notes/Web/server-side_request_forgery_(ssrf)" /> <author> <name>bipboup</name> </author> <category term="Notes" /> <category term="Web" /> <summary> Qu’est-ce qu’une vulnérabilité SSRF (Server-Side Request Forgery) ? La SSRF est une vulnérabilité qui permet à un attaquant de manipuler un serveur pour qu’il effectue des requêtes vers des ressources externes ou internes non prévues. En utilisant une SSRF, un attaquant peut contourner les firewallls, les ACLs (Access Control List) et les IPS (Intrusion Prevention System) et accéder à des serv... </summary> </entry> <entry><title>CTFs | HeroCTF2024 | Web | PrYzes</title><link href="axelinsa.github.io/CTFs/HeroCTF2024/Web/PrYzes" rel="alternate" type="text/html" title="CTFs | HeroCTF2024 | Web | PrYzes" /><published>2024-10-28T00:00:00+01:00</published> <updated>2024-10-28T00:00:00+01:00</updated> <id>axelinsa.github.io/CTFs/HeroCTF2024/Web/PrYzes</id> <content src="axelinsa.github.io/CTFs/HeroCTF2024/Web/PrYzes" /> <author> <name>bipboup</name> </author> <category term="CTFs" /> <category term="HeroCTF2024" /> <category term="Web" /> <summary> PrYzes In this challenge, we are given an URL. On the home page, there is a button to “claim Prizes”. When we press it, it tells us to come back later. Here there are two options. The first one is that the time is checked server-side. In this case, we cannot influence it. The second option is that the time is provided by the web browser. Here is the request sent to get the prize. POST /... </summary> </entry> <entry><title>CTFs | HeroCTF2024 | Crypto | Paranoia</title><link href="axelinsa.github.io/CTFs/HeroCTF2024/Crypto/Paranoia" rel="alternate" type="text/html" title="CTFs | HeroCTF2024 | Crypto | Paranoia" /><published>2024-10-28T00:00:00+01:00</published> <updated>2024-10-28T00:00:00+01:00</updated> <id>axelinsa.github.io/CTFs/HeroCTF2024/Crypto/Paranoia</id> <content src="axelinsa.github.io/CTFs/HeroCTF2024/Crypto/Paranoia" /> <author> <name>bipboup</name> </author> <category term="CTFs" /> <category term="HeroCTF2024" /> <category term="Crypto" /> <summary> Paranoia In this challenge, we are given the following code. from cryptography.hazmat.primitives.ciphers.algorithms import AES, SM4 from cryptography.hazmat.primitives.ciphers import Cipher, modes import os class Paranoia: def __init__(self, keys): self.keys = keys def __pad(self, data: bytes, bs: int) -&amp;gt; bytes: return data + (chr(bs - len(data) % bs) * (bs - len(data) % bs)).encode... </summary> </entry> <entry><title>CTFs | HeroCTF2024 | Crypto | Interpolation</title><link href="axelinsa.github.io/CTFs/HeroCTF2024/Crypto/Interpolation" rel="alternate" type="text/html" title="CTFs | HeroCTF2024 | Crypto | Interpolation" /><published>2024-10-28T00:00:00+01:00</published> <updated>2024-10-28T00:00:00+01:00</updated> <id>axelinsa.github.io/CTFs/HeroCTF2024/Crypto/Interpolation</id> <content src="axelinsa.github.io/CTFs/HeroCTF2024/Crypto/Interpolation" /> <author> <name>bipboup</name> </author> <category term="CTFs" /> <category term="HeroCTF2024" /> <category term="Crypto" /> <summary> Understanding the challenge In this challenge we are given this sage code: #!/usr/bin/sage import hashlib import re with open("flag.txt", "rb") as f: FLAG = f.read() assert re.match(rb"Hero{[0-9a-zA-Z_]{90}}", FLAG) F = FiniteField(2**256 - 189) R = PolynomialRing(F, "x") H = lambda n: int(hashlib.sha256(n).hexdigest(), 16) C = lambda x: [H(x[i : i + 4]) for i in range(0, len(FLAG... </summary> </entry> <entry><title>Notes | SQL Injections</title><link href="axelinsa.github.io/Notes/Web/sql_injections" rel="alternate" type="text/html" title="Notes | SQL Injections" /><published>2024-10-20T00:00:00+02:00</published> <updated>2024-10-21T08:52:52+02:00</updated> <id>axelinsa.github.io/Notes/Web/sql_injections</id> <content src="axelinsa.github.io/Notes/Web/sql_injections" /> <author> <name>bipboup</name> </author> <category term="Notes" /> <category term="Web" /> <summary> Qu’est-ce qu’une injection SQL (SQLi) ? Une injection SQL (SQLi) est une vulnérabilité web critique qui permet à un attaquant d’envoyer des requêtes malveillantes à la base de données d’une application. Cette attaque est possible lorsque les entrées utilisateur, telles que les champs de formulaire, les URL, ou même les cookies, sont intégrées directement dans les requêtes SQL sans être correct... </summary> </entry> </feed>
